!****************************************************************************
!
!  PROGRAM : Cross_check
!
!  PURPOSE : 2선분 간의 교차 검사
!
!****************************************************************************
Subroutine calc_cross(l_a, l_b, l_c, l_d, judgment)

implicit none

real, intent(in) :: l_a(2), l_b(2), l_c(2), l_d(2)
logical, intent(inout) :: judgment

real :: v(2,2), z(4), c(2)

v(1,1) = l_b(1) - l_a(1)
v(1,2) = l_b(2) - l_a(2)
v(2,1) = l_c(1) - l_a(1)
v(2,2) = l_c(2) - l_a(2)
z(1) = (v(1,1) * v(2,2)) - (v(2,1) * v(1,2))

v(1,1) = l_b(1) - l_a(1)
v(1,2) = l_b(2) - l_a(2)
v(2,1) = l_d(1) - l_a(1)
v(2,2) = l_d(2) - l_a(2)
z(2) = (v(1,1) * v(2,2)) - (v(2,1) * v(1,2))

v(1,1) = l_d(1) - l_c(1)
v(1,2) = l_d(2) - l_c(2)
v(2,1) = l_a(1) - l_c(1)
v(2,2) = l_a(2) - l_c(2)
z(3) = (v(1,1) * v(2,2)) - (v(2,1) * v(1,2))

v(1,1) = l_d(1) - l_c(1)
v(1,2) = l_d(2) - l_c(2)
v(2,1) = l_b(1) - l_c(1)
v(2,2) = l_b(2) - l_c(2)
z(4) = (v(1,1) * v(2,2)) - (v(2,1) * v(1,2))

c(1) = z(1) * z(2)
c(2) = z(3) * z(4)

if ((c(1) .LE. -0.0000001) .AND. (c(2) .LE. -0.0000001)) then
	judgment = .FALSE.
else
	judgment = .TRUE.
endif

end subroutine
!======================================================================================
Subroutine calc_cross_con(l_a, l_b, l_c, l_d, judgment)

implicit none

real, intent(in) :: l_a(1,1:2), l_b(1,1:2), l_c(1,1:2), l_d(1,1:2)
logical, intent(inout) :: judgment

real :: v(2,2), z(4), c(2)

v(1,1) = l_b(1,1) - l_a(1,1)
v(1,2) = l_b(1,2) - l_a(1,2)
v(2,1) = l_c(1,1) - l_a(1,1)
v(2,2) = l_c(1,2) - l_a(1,2)
z(1) = (v(1,1) * v(2,2)) - (v(2,1) * v(1,2))

v(1,1) = l_b(1,1) - l_a(1,1)
v(1,2) = l_b(1,2) - l_a(1,2)
v(2,1) = l_d(1,1) - l_a(1,1)
v(2,2) = l_d(1,2) - l_a(1,2)
z(2) = (v(1,1) * v(2,2)) - (v(2,1) * v(1,2))

v(1,1) = l_d(1,1) - l_c(1,1)
v(1,2) = l_d(1,2) - l_c(1,2)
v(2,1) = l_a(1,1) - l_c(1,1)
v(2,2) = l_a(1,2) - l_c(1,2)
z(3) = (v(1,1) * v(2,2)) - (v(2,1) * v(1,2))

v(1,1) = l_d(1,1) - l_c(1,1)
v(1,2) = l_d(1,2) - l_c(1,2)
v(2,1) = l_b(1,1) - l_c(1,1)
v(2,2) = l_b(1,2) - l_c(1,2)
z(4) = (v(1,1) * v(2,2)) - (v(2,1) * v(1,2))

c(1) = z(1) * z(2)
c(2) = z(3) * z(4)

if ((c(1) .LE. 0.0) .AND. (c(2) .LE. 0.0)) then
	
	judgment = .FALSE.

else

	judgment = .TRUE.

endif

end subroutine
!======================================================================================
! 교차점 구하기 
Subroutine calc_cross_p(l_a, l_b, l_c, l_d, cross)

real, intent(in) :: l_a(2), l_b(2), l_c(2), l_d(2)
real, intent(out) :: cross(2)

real :: x

x = (((l_d(1)-l_c(1)) * (l_a(2)-l_c(2)))-((l_d(2)-l_c(2)) * (l_a(1)-l_c(1)))) / (((l_d(2)-l_c(2)) * (l_b(1)-l_a(1)))-((l_d(1)-l_c(1)) * (l_b(2)-l_a(2))))

cross(1) = l_a(1) + x * (l_b(1) - l_a(1))
cross(2) = l_a(2) + x * (l_b(2) - l_a(2))

end subroutine
! 교차점 구하기 종료
!======================================================================================