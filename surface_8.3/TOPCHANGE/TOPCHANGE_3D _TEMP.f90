    MODULE TOPCHANGE_3D
    USE SURFACE_MODULE_3D
    
    IMPLICIT NONE

    CONTAINS
    

    SUBROUTINE ATTACH_BOUNDARY(TYP, BOUNDARY1_NUM, BOUNDARY1, BOUNDARY1_POINT, BOUNDARY1_CONNECTING_NUM, BOUNDARY2_NUM, BOUNDARY2, BOUNDARY2_CONNECTING_NUM, BOUNDARY2_POINT)
    IMPLICIT NONE
    INTEGER :: TYP
    INTEGER :: BOUNDARY1_NUM, BOUNDARY2_NUM
    INTEGER, DIMENSION(:,:) :: BOUNDARY1, BOUNDARY2
    REAL(8), DIMENSION(:,:) :: BOUNDARY1_POINT, BOUNDARY2_POINT
    INTEGER, DIMENSION(:) :: BOUNDARY1_CONNECTING_NUM, BOUNDARY2_CONNECTING_NUM
    INTEGER :: COUNTING, TEMP_BOUNDARY1_NUM, TEMP_BOUNDARY2_NUM, TEMP1, TEMP2
    INTEGER :: BOUNDARY1_POINT_INDEX1, BOUNDARY1_POINT_INDEX2, BOUNDARY2_POINT_INDEX1, BOUNDARY2_POINT_INDEX2
    REAL(8) :: BOUNDARY1_POINT1(3), BOUNDARY1_POINT2(3), BOUNDARY2_POINT1(3), BOUNDARY2_POINT2(3)
    REAL(8) :: DISTANCE1, DISTANCE2
    INTEGER, ALLOCATABLE :: TEMP_FACE(:,:)
    INTEGER :: FACE_NUM, I
    TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT


    IF (TYP==0) THEN
	SURFACE_CURRENT => SURFACE_FLUID
    ELSE IF (TYP==1) THEN
	SURFACE_CURRENT => SURFACE_PROPEL
    ELSE
	SURFACE_CURRENT => SURFACE_FLUID
    END IF

    ALLOCATE(TEMP_FACE(3,1000))
    FACE_NUM = 0
    COUNTING = 0
    TEMP_BOUNDARY1_NUM = 0
    TEMP_BOUNDARY2_NUM = 0
    DO WHILE(TEMP_BOUNDARY1_NUM<BOUNDARY1_NUM .AND. TEMP_BOUNDARY2_NUM<BOUNDARY1_NUM)
        COUNTING = COUNTING + 1
	TEMP1 = 0
	TEMP2 = 0

	    DO WHILE (TEMP1<BOUNDARY1_CONNECTING_NUM(COUNTING) .AND. TEMP2<BOUNDARY2_CONNECTING_NUM(COUNTING))
		BOUNDARY1_POINT_INDEX1 = BOUNDARY1(1,TEMP_BOUNDARY1_NUM+1)
		BOUNDARY1_POINT_INDEX2 = BOUNDARY1(2,TEMP_BOUNDARY1_NUM+1)
		BOUNDARY2_POINT_INDEX1 = BOUNDARY2(1,TEMP_BOUNDARY2_NUM+1)
		BOUNDARY2_POINT_INDEX2 = BOUNDARY2(2,TEMP_BOUNDARY2_NUM+1)
		BOUNDARY1_POINT1 = BOUNDARY1_POINT(:,BOUNDARY1_POINT_INDEX1)
		BOUNDARY1_POINT2 = BOUNDARY1_POINT(:,BOUNDARY1_POINT_INDEX2)
		BOUNDARY2_POINT1 = BOUNDARY2_POINT(:,BOUNDARY2_POINT_INDEX1)
		BOUNDARY2_POINT2 = BOUNDARY2_POINT(:,BOUNDARY2_POINT_INDEX2)

		DISTANCE1 = DOT_PRODUCT(BOUNDARY1_POINT1-BOUNDARY2_POINT2,BOUNDARY1_POINT1-BOUNDARY2_POINT2)
		DISTANCE2 = DOT_PRODUCT(BOUNDARY1_POINT2-BOUNDARY2_POINT1,BOUNDARY1_POINT2-BOUNDARY2_POINT1)
!!!! 아마 temp_face의 orientation에 문제가 있을듯.... orientation을 뭘로 결정할 것이냐!!!!
		IF (DISTANCE1<DISTANCE2) THEN
		    FACE_NUM = FACE_NUM + 1
		    TEMP_FACE(1, FACE_NUM) = BOUNDARY1_POINT_INDEX1
		    TEMP_FACE(2, FACE_NUM) = BOUNDARY2_POINT_INDEX1
		    TEMP_FACE(3, FACE_NUM) = BOUNDARY2_POINT_INDEX2

		    TEMP_BOUNDARY1_NUM = TEMP_BOUNDARY1_NUM
		    TEMP_BOUNDARY1_NUM = TEMP_BOUNDARY1_NUM + 1
		    TEMP1 = TEMP1
		    TEMP2 = TEMP2 + 1
		ELSE
		    FACE_NUM = FACE_NUM + 1
		    TEMP_FACE(1, FACE_NUM) = BOUNDARY2_POINT_INDEX1
		    TEMP_FACE(2, FACE_NUM) = BOUNDARY1_POINT_INDEX2
		    TEMP_FACE(3, FACE_NUM) = BOUNDARY1_POINT_INDEX1

		    TEMP_BOUNDARY1_NUM = TEMP_BOUNDARY1_NUM + 1
		    TEMP_BOUNDARY1_NUM = TEMP_BOUNDARY1_NUM
		    TEMP1 = TEMP1 + 1
		    TEMP2 = TEMP2
		END IF


		IF (TEMP1==BOUNDARY1_CONNECTING_NUM(COUNTING) .AND. TEMP2<BOUNDARY2_CONNECTING_NUM(COUNTING)) THEN
		    DO WHILE(TEMP2<BOUNDARY2_CONNECTING_NUM(COUNTING))
			FACE_NUM = FACE_NUM + 1

			BOUNDARY1_POINT_INDEX2 = BOUNDARY1(2,TEMP_BOUNDARY1_NUM)
			BOUNDARY2_POINT_INDEX1 = BOUNDARY2(1,TEMP_BOUNDARY2_NUM+1)
			BOUNDARY2_POINT_INDEX2 = BOUNDARY2(2,TEMP_BOUNDARY2_NUM+1)
			TEMP_FACE(1, FACE_NUM) = BOUNDARY1_POINT_INDEX2
			TEMP_FACE(2, FACE_NUM) = BOUNDARY2_POINT_INDEX1
			TEMP_FACE(3, FACE_NUM) = BOUNDARY2_POINT_INDEX2

			TEMP_BOUNDARY1_NUM = TEMP_BOUNDARY1_NUM
			TEMP_BOUNDARY1_NUM = TEMP_BOUNDARY1_NUM + 1
		        TEMP1 = TEMP1
		        TEMP2 = TEMP2 + 1
		    END DO
		END IF

		IF (TEMP1<BOUNDARY1_CONNECTING_NUM(COUNTING) .AND. TEMP2==BOUNDARY2_CONNECTING_NUM(COUNTING)) THEN
		    DO WHILE(TEMP1<BOUNDARY1_CONNECTING_NUM(COUNTING))
			FACE_NUM = FACE_NUM + 1

			BOUNDARY1_POINT_INDEX1 = BOUNDARY1(1,TEMP_BOUNDARY1_NUM+1)
			BOUNDARY1_POINT_INDEX2 = BOUNDARY1(2,TEMP_BOUNDARY1_NUM+1)
			BOUNDARY2_POINT_INDEX2 = BOUNDARY2(2,TEMP_BOUNDARY2_NUM)
			TEMP_FACE(1, FACE_NUM) = BOUNDARY2_POINT_INDEX2
			TEMP_FACE(2, FACE_NUM) = BOUNDARY1_POINT_INDEX2
			TEMP_FACE(3, FACE_NUM) = BOUNDARY1_POINT_INDEX1

			TEMP_BOUNDARY1_NUM = TEMP_BOUNDARY1_NUM + 1
			TEMP_BOUNDARY1_NUM = TEMP_BOUNDARY1_NUM
		        TEMP1 = TEMP1 + 1
		        TEMP2 = TEMP2
		    END DO
		END IF

	END DO


    END DO

    DO I = 1, FACE_NUM

    END DO


    DEALLOCATE(TEMP_FACE)
    END SUBROUTINE

    SUBROUTINE ATTACH_BOUNDARIES(TYP, REMOVE_PAIR_NUM, REMOVE_PAIR, REMOVE_CLUSTER)
    IMPLICIT NONE
    
    INTEGER :: TYP
    INTEGER :: REMOVE_PAIR_NUM
    INTEGER :: REMOVE_PAIR(:,:)
    INTEGER :: REMOVE_CLUSTER(:,:)
    
    TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT
    
    IF (TYP==0) THEN
        SURFACE_CURRENT => SURFACE_FLUID
    END IF
    IF (TYP==1) THEN
        SURFACE_CURRENT => SURFACE_PROPEL
    END IF
    IF (TYP==2) THEN
        SURFACE_CURRENT => SURFACE_CASE
    END IF
    
    !! 1. attach boundaries
    
    DO ITER=1,REMOVE_PAIR_NUM
        ITER1 = REMOVE_PAIR(1,ITER)
        ITER2 = REMOVE_PAIR(2,ITER)
        
        
    END DO
    
    !! 2. setting new region & boundaries
    
    !! 3. remove faces
    
    ALLOCATE(B_REMOVE_FACE(SURFACE_CURRENT%SURFACE_FACES_NUM))
    B_REMOVE_FACE(:) = .FALSE.
    
    DO ITER=1,REMOVE_PAIR_NUM
        ITER1 = REMOVE_PAIR(1,ITER)
        ITER2 = REMOVE_PAIR(2,ITER)
        
        I = 1
        DO WHILE(REMOVE_CLUSTER(I,ITER1) .NE. 0)
            B_REMOVE_FACE(REMOVE_CLUSTER(I,ITER1)) = .TRUE.
            I = I + 1
        END DO
        
        IF(ITER1 .NE. ITER2) THEN
        
        I = 1
        DO WHILE(REMOVE_CLUSTER(I,ITER2) .NE. 0)
            B_REMOVE_FACE(REMOVE_CLUSTER(I,ITER2)) = .TRUE.
            I = I + 1
        END DO
        
        END IF
        
    END DO
    
    CALL REMOVE_CERTAIN_FACES(TYP, B_REMOVE_FACE)
    
    DEALLOCATE(B_REMOVE_FACE)
    
    END SUBROUTINE
    
    SUBROUTINE REMOVE_CERTAIN_FACES(TYP, B_REMOVE_FACE)
    IMPLICIT NONE
    
    INTEGER :: TYP
    LOGICAL :: B_REMOVE_FACE(:)
    
    INTEGER :: I, J
    LOGICAL :: B
    INTEGER :: NEWPOINT_NUM, NEWFACE_NUM
    REAL(8), ALLOCATABLE :: NEWPOINT(:,:) 
    INTEGER, ALLOCATABLE :: NEWFACE(:,:)
    INTEGER, ALLOCATABLE :: POINT_INDEX(:)
    INTEGER, ALLOCATABLE :: FACE_INDEX(:)
    
    TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT
    
    IF (TYP==0) THEN
        SURFACE_CURRENT => SURFACE_FLUID
    END IF
    IF (TYP==1) THEN
        SURFACE_CURRENT => SURFACE_PROPEL
    END IF
    IF (TYP==2) THEN
        SURFACE_CURRENT => SURFACE_CASE
    END IF

    ALLOCATE(NEWPOINT(3,SURFACE_CURRENT%SURFACE_POINTS_NUM))
    ALLOCATE(NEWFACE(3,SURFACE_CURRENT%SURFACE_FACES_NUM))
    ALLOCATE(POINT_INDEX(SURFACE_CURRENT%SURFACE_POINTS_NUM))
    ALLOCATE(FACE_INDEX(SURFACE_CURRENT%SURFACE_FACES_NUM))

    POINT_INDEX(:) = 0
    FACE_INDEX(:) = 0

    NEWPOINT_NUM = 0

    DO I = 1, SURFACE_CURRENT%SURFACE_POINTS_NUM
        B = .FALSE.
        DO J = 1, SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(I)
            IF(.NOT. B_REMOVE_FACE(SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I)) THEN
                B = .TRUE.
            END IF
        END DO
        
        IF(B) THEN
            NEWPOINT_NUM = NEWPOINT_NUM+1
            NEWPOINT(:,NEWPOINT_NUM) = SURFACE_CURRENT%SURFACE_POINTS(:,I)
            POINT_INDEX(I) = NEWPOINT_NUM
        END IF
    END DO

    NEWFACE_NUM = 0

    DO J = 1, SURFACE_CURRENT%SURFACE_FACES_NUM
        IF(.NOT. B_REMOVE_FACE(J)) THEN
            NEWFACE_NUM = NEWFACE_NUM+1
            NEWFACE(:,NEWFACE_NUM) = SURFACE_CURRENT%SURFACE_FACES(:,J)
            FACE_INDEX(J) = NEWFACE_NUM
        END IF
    END DO

    CALL NEW_POINTFACE_INDEX(TYP, NEWPOINT_NUM, NEWPOINT, NEWFACE_NUM, NEWFACE, POINT_INDEX, FACE_INDEX)

    !IF(TYP==1) THEN
    !    CALL CLASSIFY_PATCH(1)
    !END IF

    DEALLOCATE(NEWPOINT)
    DEALLOCATE(NEWFACE)
    DEALLOCATE(POINT_INDEX)
    DEALLOCATE(FACE_INDEX)
    
    END SUBROUTINE
    
    SUBROUTINE FIND_REMOVE_PAIRS(TYP, REMOVE_CLUSTER_NUM, REMOVE_CLUSTER, REMOVE_PAIR_NUM, REMOVE_PAIR)
    IMPLICIT NONE
    INTEGER :: TYP
    INTEGER :: REMOVE_CLUSTER_NUM
    INTEGER :: REMOVE_CLUSTER(:,:)
    INTEGER :: REMOVE_PAIR_NUM
    INTEGER :: REMOVE_PAIR(:,:)

    TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT
    
    IF (TYP==0) THEN
        SURFACE_CURRENT => SURFACE_FLUID
    END IF
    IF (TYP==1) THEN
        SURFACE_CURRENT => SURFACE_PROPEL
    END IF
    IF (TYP==2) THEN
        SURFACE_CURRENT => SURFACE_CASE
    END IF
    
    ALLOCATE(REMOVE_CLUSTER_INDEX(SURFACE_CURRENT%SURFACE_FACES_NUM))
    REMOVE_CLUSTER_INDEX(:) = 0
    
    DO ITER=1,REMOVE_CLUSTER_NUM
        I = 1
        DO WHILE(REMOVE_CLUSTER(I,ITER) .NE. 0)
            REMOVE_CLUSTER_INDEX(REMOVE_CLUSTER(I,ITER)) = ITER
            I = I + 1
        END DO
    END DO
    
    REMOVE_PAIR_NUM = 0
    REMOVE_PAIR(1:2, REMOVE_PAIR_NUM+1) = 0
    DO ITER=1,REMOVE_CLUSTER_NUM
        
        B = .TRUE.
        
        DO I = 1,REMOVE_PAIR_NUM
            IF(REMOVE_PAIR(1,I)==ITER .OR. REMOVE_PAIR(2,I)==ITER) THEN
                B = .FALSE.
                EXIT
            END IF
        END DO
        
        IF(B) THEN
        
        I = 1
        DO WHILE(REMOVE_CLUSTER(I,ITER) .NE. 0)
            I1 = REMOVE_CLUSTER(I,ITER)
            IPZ = SURFACE_CURRENT%FACE_IMPACT_ZONE(TYP+1, I1)
            
            IF(REMOVE_CLUSTER_INDEX(IPZ) .NE. 0) THEN
                REMOVE_PAIR_NUM = REMOVE_PAIR_NUM + 1
                REMOVE_PAIR(1,REMOVE_PAIR_NUM) = ITER
                REMOVE_PAIR(2,REMOVE_PAIR_NUM) = REMOVE_CLUSTER_INDEX(IPZ)
            END IF
            
            I = I + 1
        END DO
        
        END IF
    END DO
    
    DEALLOCATE(REMOVE_CLUSTER_INDEX)
    
    END SUBROUTINE
    
    SUBROUTINE FIND_REMOVE_CLUSTERS(TYP, B_REMOVE_FACE, REMOVE_CLUSTER_NUM, REMOVE_CLUSTER)
    IMPLICIT NONE
    INTEGER :: TYP
    LOGICAL :: B_REMOVE_FACE
    INTEGER :: REMOVE_CLUSTER_NUM
    INTEGER :: REMOVE_CLUSTER(:,:)

    TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT
    
    IF (TYP==0) THEN
        SURFACE_CURRENT => SURFACE_FLUID
    END IF
    IF (TYP==1) THEN
        SURFACE_CURRENT => SURFACE_PROPEL
    END IF
    IF (TYP==2) THEN
        SURFACE_CURRENT => SURFACE_CASE
    END IF
    
    
    
    
    END SUBROUTINE
    
    SUBROUTINE FIND_REMOVE_FACES(TYP, THRESHOLD, FLAG, B_REMOVE_FACE, REMOVE_CLUSTER, REMOVE_PAIR_NUM, REMOVE_PAIR)
    IMPLICIT NONE
    INTEGER :: TYP
    LOGICAL :: B_REMOVE_FACE
    INTEGER :: REMOVE_CLUSTER_NUM
    INTEGER :: REMOVE_CLUSTER(:,:)
    INTEGER :: REMOVE_PAIR_NUM
    INTEGER :: REMOVE_PAIR(:,:)
    
    INTEGER :: I, J, K, IPZ, DIR, PAIR_NUM
    !INTEGER :: I1, I2, J1, J2, IPZ1, IPZ2, IND
    REAL(8) :: R !, R1, R2, R3
    !INTEGER, ALLOCATABLE :: PATCH_PARENT(:), PATCH_BEFORE_INDEX(:)
    LOGICAL :: B, FLAG, TEMPFLAG

    TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT
    
    IF (TYP==0) THEN
        SURFACE_CURRENT => SURFACE_FLUID
    END IF
    IF (TYP==1) THEN
        SURFACE_CURRENT => SURFACE_PROPEL
    END IF
    IF (TYP==2) THEN
        SURFACE_CURRENT => SURFACE_CASE
    END IF

    FLAG = .FALSE.

    TEMPFLAG = .FALSE.

    B = .TRUE.
    DIR = 0

    DO I=1,SURFACE_CURRENT%SURFACE_FACES_NUM
        IPZ = SURFACE_CURRENT%FACE_IMPACT_ZONE(TYP+1, I)
        IF(IPZ.NE.0) THEN
            CALL DISTANCE_FACE_FACE_TYPE(I,TYP,IPZ,TYP,DIR,  R,B)
            IF(R < THRESHOLD) THEN
                TEMPFLAG = .TRUE.
                EXIT
            END IF
        END IF
    END DO

    PAIR_NUM = 0
    IF(TEMPFLAG) THEN

    ALLOCATE(TEMP_B_REMOVE_FACE(SURFACE_CURRENT%SURFACE_FACES_NUM), BEFORE_B_REMOVE_FACE(SURFACE_CURRENT%SURFACE_FACES_NUM))
    B_REMOVE_FACE(:) = .FALSE.

    DO I=1,SURFACE_CURRENT%SURFACE_FACES_NUM
        IPZ = SURFACE_CURRENT%FACE_IMPACT_ZONE(TYP+1, I)
        IF(IPZ.NE.0) THEN
            CALL DISTANCE_FACE_FACE_TYPE(I,TYP,IPZ,TYP,DIR,  R,B)
            IF(R < THRESHOLD * 1.5) THEN
                B_REMOVE_FACE(I) = .TRUE.
            END IF
        END IF
    END DO
    
    
    B = .TRUE.
    
    DO WHILE(B)
    
    B = .FALSE.
    
    DO I=1,SURFACE_CURRENT%SURFACE_FACES_NUM
        IF(B_REMOVE_FACE(I) .AND. SURFACE_CURRENT%FACE_ONINTERFACE(I)==1-TYP) THEN
            BOUNDARY_NUM = 0
            DO K=1,3
                CALL FACE_NEIGHBOR_FACE(SURFACE_CURRENT%SURFACE_FACES, SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM, SURFACE_CURRENT%POINT_FACE_CONNECTION,I,K, I1)
                IF(.NOT. B_REMOVE_FACE(I1) .AND. SURFACE_CURRENT%FACE_ONINTERFACE(I1)==1-TYP) THEN
                    BOUNDARY_NUM = BOUNDARY_NUM + 1
                END IF
            END DO
            IF(BOUNDARY_NUM >= 2) THEN
                B = .TRUE.
                B_REMOVE_FACE(I) = .FALSE.
            END IF
        END IF
    END DO
    
    END DO
    
    B = .TRUE.
    
    DO WHILE(B)
    
    B = .FALSE.
    
    BEFORE_B_REMOVE_FACE(:) = B_REMOVE_FACE(:)
    TEMP_B_REMOVE_FACE(:) = B_REMOVE_FACE(:)
    
    DO I=1,SURFACE_CURRENT%SURFACE_POINTS_NUM
        C = .FALSE.
        D = .FALSE.
        DO J=1,SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(I)
            I1 = SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I)
            IF(B_REMOVE_FACE(I1)) THEN
                C = .TRUE.
            ELSE IF(.NOT. B_REMOVE_FACE(I1) .AND. SURFACE_CURRENT%FACE_ONINTERFACE(I1)==1-TYP) THEN
                D = .TRUE.
            END IF
        END DO
        
        IF(C .AND. D) THEN
        
        DO J=1,SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(I)
            I1 = SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I)
            IF(.NOT. B_REMOVE_FACE(I1) .AND. SURFACE_CURRENT%FACE_ONINTERFACE(I1)==1-TYP) THEN
                TEMP_B_REMOVE_FACE(I1) = .TRUE.
            END IF
        END DO
        
        END IF
    END DO
    
    B_REMOVE_FACE(:) = TEMP_B_REMOVE_FACE(:)
    
    DO I=1,SURFACE_CURRENT%SURFACE_POINTS_NUM
        C = .FALSE.
        D = .FALSE.
        DO J=1,SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(I)
            I1 = SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I)
            IF(B_REMOVE_FACE(I1) .AND. SURFACE_CURRENT%FACE_ONINTERFACE(I1)==1-TYP) THEN
                C = .TRUE.
            ELSE IF(.NOT. B_REMOVE_FACE(I1) .AND. SURFACE_CURRENT%FACE_ONINTERFACE(I1)==1-TYP) THEN
                D = .TRUE.
            END IF
        END DO
        
        IF(C .AND. D) THEN
        
        DO J=1,SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(I)
            I1 = SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I)
            IF(B_REMOVE_FACE(I1) .AND. SURFACE_CURRENT%FACE_ONINTERFACE(I1)==1-TYP) THEN
                TEMP_B_REMOVE_FACE(I1) = .FALSE.
            END IF
        END DO
        
        END IF
    END DO
    
    B_REMOVE_FACE(:) = TEMP_B_REMOVE_FACE(:)
    
    DO I=1,SURFACE_CURRENT%SURFACE_FACES_NUM
        IF(B_REMOVE_FACE(I) .NE. BEFORE_B_REMOVE_FACE(I)) THEN
            B = .TRUE.
            EXIT
        END IF
    END DO
    
    END DO
    
    B = .TRUE.
    
    DO WHILE(B)
    
    B = .FALSE.
    
    DO I=1,SURFACE_CURRENT%SURFACE_FACES_NUM
        IF(B_REMOVE_FACE(I) .AND. SURFACE_CURRENT%FACE_ONINTERFACE(I)==1-TYP) THEN
            BOUNDARY_NUM = 0
            DO K=1,3
                CALL FACE_NEIGHBOR_FACE(SURFACE_CURRENT%SURFACE_FACES, SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM, SURFACE_CURRENT%POINT_FACE_CONNECTION,I,K, I1)
                IF(.NOT. B_REMOVE_FACE(I1) .AND. SURFACE_CURRENT%FACE_ONINTERFACE(I1)==1-TYP) THEN
                    BOUNDARY_NUM = BOUNDARY_NUM + 1
                END IF
            END DO
            IF(BOUNDARY_NUM >= 2) THEN
                B = .TRUE.
                B_REMOVE_FACE(I) = .FALSE.
            END IF
        END IF
    END DO
    
    END DO
    
    CALL FIND_REMOVE_CLUSTERS(TYP, B_REMOVE_FACE, REMOVE_CLUSTER_NUM, REMOVE_CLUSTER)
    
    CALL FIND_REMOVE_PAIRS(TYP, REMOVE_CLUSTER_NUM, REMOVE_CLUSTER, REMOVE_PAIR_NUM, REMOVE_PAIR)
    
    DEALLOCATE(TEMP_B_REMOVE_FACE, BEFORE_B_REMOVE_FACE)
    
    END IF

    !DEALLOCATE(PATCH_PARENT)

    END SUBROUTINE
    
    SUBROUTINE REMOVE_LARGE_REGION(TYP, REGION_NUM)
    IMPLICIT NONE
    INTEGER :: TYP
    INTEGER :: I, J
    INTEGER :: ITER, REGION_NUM
    LOGICAL :: B
    INTEGER :: NEWPOINT_NUM, NEWFACE_NUM
    REAL(8), ALLOCATABLE :: NEWPOINT(:,:) 
    INTEGER, ALLOCATABLE :: NEWFACE(:,:)
    INTEGER, ALLOCATABLE :: POINT_INDEX(:)
    INTEGER, ALLOCATABLE :: FACE_INDEX(:)
    TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT

    
    IF (TYP==0) THEN
        SURFACE_CURRENT => SURFACE_FLUID
    END IF
    IF (TYP==1) THEN
        SURFACE_CURRENT => SURFACE_PROPEL
    END IF
    IF (TYP==2) THEN
        SURFACE_CURRENT => SURFACE_CASE
    END IF

    ALLOCATE(NEWPOINT(3,SURFACE_CURRENT%SURFACE_POINTS_NUM))
    ALLOCATE(NEWFACE(3,SURFACE_CURRENT%SURFACE_FACES_NUM))
    ALLOCATE(POINT_INDEX(SURFACE_CURRENT%SURFACE_POINTS_NUM))
    ALLOCATE(FACE_INDEX(SURFACE_CURRENT%SURFACE_FACES_NUM))

    POINT_INDEX(:) = 0
    FACE_INDEX(:) = 0

    NEWPOINT_NUM = 0
    B = .TRUE.
    ITER = 1


    DO WHILE(B)
        B = .FALSE.
        DO I = 1, SURFACE_CURRENT%SURFACE_POINTS_NUM
            IF(SURFACE_CURRENT%FACE_LOCATION(SURFACE_CURRENT%POINT_FACE_CONNECTION(1,I))==ITER) THEN
                B = .TRUE.
                IF(ITER .NE. REGION_NUM) THEN
                    NEWPOINT_NUM = NEWPOINT_NUM+1
                    NEWPOINT(:,NEWPOINT_NUM) = SURFACE_CURRENT%SURFACE_POINTS(:,I)
                    POINT_INDEX(I) = NEWPOINT_NUM
                END IF
            END IF
        END DO
        ITER = ITER + 1
    END DO

    NEWFACE_NUM = 0
    B = .TRUE.
    ITER = 1

    DO WHILE(B)
        B = .FALSE.
        DO J = 1, SURFACE_CURRENT%SURFACE_FACES_NUM
            IF(SURFACE_CURRENT%FACE_LOCATION(J)==ITER) THEN
                B = .TRUE.
                IF(ITER .NE. REGION_NUM) THEN
                    NEWFACE_NUM = NEWFACE_NUM+1
                    NEWFACE(:,NEWFACE_NUM) = SURFACE_CURRENT%SURFACE_FACES(:,J)
                    FACE_INDEX(J) = NEWFACE_NUM
                END IF
            END IF
        END DO
        ITER = ITER + 1
    END DO

    !write(*,*) 'NEWPOINT NUM', NEWPOINT_NUM
    !write(*,*) 'NEWFACE NUM', NEWFACE_NUM

    CALL NEW_POINTFACE_INDEX(TYP, NEWPOINT_NUM, NEWPOINT, NEWFACE_NUM, NEWFACE, POINT_INDEX, FACE_INDEX)

    !IF(TYP==1) THEN
    !    CALL CLASSIFY_PATCH(1)
    !END IF

    DEALLOCATE(NEWPOINT)
    DEALLOCATE(NEWFACE)
    DEALLOCATE(POINT_INDEX)
    DEALLOCATE(FACE_INDEX)

    END SUBROUTINE REMOVE_LARGE_REGION


    SUBROUTINE ZIPPER_PROPEL_IMPACT_ZONE(FLAG)
    IMPLICIT NONE
    INTEGER :: I, J, K, IPZ, DIR, PAIR_NUM
    !INTEGER :: I1, I2, J1, J2, IPZ1, IPZ2, IND
    REAL(8) :: R !, R1, R2, R3
    INTEGER, ALLOCATABLE :: MATCH_INDEX(:,:)!, PATCH_PARENT(:), PATCH_BEFORE_INDEX(:)
    LOGICAL :: B, FLAG, TEMPFLAG, THINFLAG

    FLAG = .FALSE.

    TEMPFLAG = .FALSE.
    THINFLAG = .FALSE.
    B = .TRUE.
    DIR = 0
    ALLOCATE(MATCH_INDEX(SURFACE_PROPEL%SURFACE_FACES_NUM,2))
    !ALLOCATE(PATCH_PARENT(SURFACE_PROPEL%SURFACE_FACES_NUM))

    !DO J=1,SURFACE_PROPEL%SURFACE_PATCHES_NUM
    !    DO I=1,SURFACE_PROPEL%SURFACE_FACES_NUM
    !        IF(SURFACE_PROPEL%FACE_LOCATION(I) .EQ. J) THEN
    !            I1 = SURFACE_PROPEL%SURFACE_EDGES(1,I)
    !            I2 = SURFACE_PROPEL%SURFACE_EDGES(2,I)
    !            J1 = SURFACE_PROPEL%POINT_EDGE_CONNECTION(1,I1)
    !            J2 = SURFACE_PROPEL%POINT_EDGE_CONNECTION(2,I2)
    !            IPZ = SURFACE_PROPEL%FACE_IMPACT_ZONE(1+1, I)
    !            IPZ1 = SURFACE_PROPEL%FACE_IMPACT_ZONE(1+1, J1)
    !            IPZ2 = SURFACE_PROPEL%FACE_IMPACT_ZONE(1+1, J2)
    !            		   
    !            IF(IPZ.NE.0 .AND. IPZ1 .NE. 0 .AND. IPZ2 .NE. 0) THEN
    !                CALL DISTANCE_FACE_FACE_TYPE(I,1,IPZ,1,DIR,  R1,B)
    !                CALL DISTANCE_FACE_FACE_TYPE(J1,1,IPZ1,1,DIR,  R2,B)
    !                CALL DISTANCE_FACE_FACE_TYPE(J2,1,IPZ2,1,DIR,  R3,B)
    !                IF(MAX(ABS(R1),MAX(ABS(R2),ABS(R3))) .LT. SURFACE_FLUID%MESH_SIZE * 10.) THEN
    !                    IND = I
    !                    THINFLAG = .TRUE.
    !                    SURFACE_PROPEL%SURFACE_PATCHES_TOPCHANGE_TYP(SURFACE_PROPEL%FACE_LOCATION(IND)) = 11
    !                    EXIT
    !                END IF
    !            END IF
    !        END IF
    !    END DO
    !END DO

    DO I=1,SURFACE_PROPEL%SURFACE_FACES_NUM
        IPZ = SURFACE_PROPEL%FACE_IMPACT_ZONE(1+1, I)
        IF(IPZ.NE.0) THEN
            CALL DISTANCE_FACE_FACE_TYPE(I,1,IPZ,1,DIR,  R,B)
            IF(R < SURFACE_FLUID%MESH_SIZE * THIN_REGION_ATTACHMENT) THEN
                TEMPFLAG = .TRUE.
                EXIT
            END IF
        END IF
    END DO

    PAIR_NUM = 0
    IF(TEMPFLAG) THEN
        DO I=1,SURFACE_PROPEL%SURFACE_FACES_NUM
            IPZ = SURFACE_PROPEL%FACE_IMPACT_ZONE(1+1, I)

            IF(IPZ.NE.0) THEN
                IF(SURFACE_PROPEL%FACE_IMPACT_ZONE(1+1,IPZ) .EQ. I) THEN
                    IF(PAIR_NUM .EQ. 0) THEN
                        PAIR_NUM = PAIR_NUM + 1
                        MATCH_INDEX(PAIR_NUM,1) = I
                        MATCH_INDEX(PAIR_NUM,2) = IPZ
                    ELSE
                        B = .TRUE.
                        DO J=1,PAIR_NUM
                            IF(MATCH_INDEX(J,2) .EQ. I) THEN
                                B = .FALSE.
                                EXIT
                            END IF
                        END DO

                        IF(B) THEN
                            PAIR_NUM = PAIR_NUM + 1
                            MATCH_INDEX(PAIR_NUM,1) = I
                            MATCH_INDEX(PAIR_NUM,2) = IPZ
                        END IF
                    END IF
                END IF
            END IF

        END DO

        DO K=1,PAIR_NUM
            CALL DISTANCE_FACE_FACE_TYPE(MATCH_INDEX(K,1),1,MATCH_INDEX(K,2),1,DIR,  R,B)
            IF(MATCH_INDEX(K,2) .NE. 0) THEN
                IF(R < SURFACE_FLUID%MESH_SIZE * THIN_REGION_ATTACHMENT * 1.5) THEN
                    SURFACE_PROPEL%SURFACE_PATCHES_TOPCHANGE_TYP(SURFACE_PROPEL%FACE_LOCATION(MATCH_INDEX(K,1))) = 3

                    CALL REMOVE_LARGE_REGION(1, SURFACE_PROPEL%FACE_LOCATION(MATCH_INDEX(K,1)))
                    !CALL ATTACH_TWO_EDGES(1, MATCH_INDEX(K,1), MATCH_INDEX(K,2))
                    FLAG = .TRUE.
                    EXIT
                END IF
            END IF
        END DO

        CALL RESET_PATCH(1)!, PATCH_BEFORE_INDEX = PATCH_BEFORE_INDEX)                
        !CALL REMOVE_SMALL_REGIONS(1, PATCH_BEFORE_INDEX, PATCH_PARENT = PATCH_PARENT, FLAG = FLAG)
    END IF

    DEALLOCATE(MATCH_INDEX)
    !DEALLOCATE(PATCH_PARENT)

    END SUBROUTINE ZIPPER_PROPEL_IMPACT_ZONE




    END MODULE
