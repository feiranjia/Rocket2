    MODULE TOPCHANGE_3D
    USE SURFACE_MODULE_3D
    USE SURFACES_3D
    USE REMESHING_3D
    
    IMPLICIT NONE

    CONTAINS
    
    
    SUBROUTINE TEST_ZIPPER(TYP, FLAG)
    IMPLICIT NONE
    INTEGER :: TYP
    LOGICAL :: FLAG
    
    REAL(8) :: THRESHOLD
    
    LOGICAL, ALLOCATABLE :: B_REMOVE_FACE(:)
    INTEGER :: REMOVE_CLUSTER_NUM
    INTEGER, ALLOCATABLE :: REMOVE_CLUSTER(:,:)
    INTEGER, ALLOCATABLE :: REMOVE_CLUSTER_INDEX(:)
    INTEGER :: REMOVE_PAIR_NUM
    INTEGER, ALLOCATABLE :: REMOVE_PAIR(:,:)
    
    INTEGER :: CLUSTER_FLAG1
    INTEGER :: BOUNDARY_NUM1
    INTEGER, ALLOCATABLE :: BOUNDARY1(:,:)
    INTEGER :: BOUNDARY_CLUSTER_NUM1
    INTEGER, ALLOCATABLE :: BOUNDARY_CLUSTER1(:,:)
    
    INTEGER :: CLUSTER_FLAG2
    INTEGER :: BOUNDARY_NUM2
    INTEGER, ALLOCATABLE :: BOUNDARY2(:,:)
    INTEGER :: BOUNDARY_CLUSTER_NUM2
    INTEGER, ALLOCATABLE :: BOUNDARY_CLUSTER2(:,:)
    
    INTEGER :: BOUNDARY_PAIR_NUM
    INTEGER, ALLOCATABLE :: BOUNDARY_PAIR(:,:)
    
    INTEGER :: I, TEMP
    
    TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT
    
    IF (TYP==0) THEN
        SURFACE_CURRENT => SURFACE_FLUID
    END IF
    IF (TYP==1) THEN
        SURFACE_CURRENT => SURFACE_PROPEL
    END IF
    IF (TYP==2) THEN
        SURFACE_CURRENT => SURFACE_CASE
    END IF

    
    ALLOCATE(B_REMOVE_FACE(SURFACE_CURRENT%SURFACE_FACES_NUM))
    B_REMOVE_FACE(:) = .FALSE.
    
    THRESHOLD = SURFACE_FLUID%MESH_SIZE * 20.
    
    CALL FIND_REMOVE_FACES(TYP, THRESHOLD, FLAG, B_REMOVE_FACE)
    
    ALLOCATE(REMOVE_CLUSTER(SURFACE_CURRENT%SURFACE_FACES_NUM +1,10), REMOVE_CLUSTER_INDEX(SURFACE_CURRENT%SURFACE_FACES_NUM))
    REMOVE_CLUSTER(:,:) = 0
    REMOVE_CLUSTER_INDEX(:) = 0
    
    CALL FIND_REMOVE_CLUSTERS(TYP, B_REMOVE_FACE, REMOVE_CLUSTER_NUM, REMOVE_CLUSTER, REMOVE_CLUSTER_INDEX)
    
    ALLOCATE(REMOVE_PAIR(2,10))
    REMOVE_PAIR(:,:) = 0
    
    CALL FIND_REMOVE_PAIRS(TYP, REMOVE_CLUSTER_NUM, REMOVE_CLUSTER, REMOVE_CLUSTER_INDEX, REMOVE_PAIR_NUM, REMOVE_PAIR)
    
    ALLOCATE(BOUNDARY1(2,SURFACE_CURRENT%SURFACE_FACES_NUM), BOUNDARY_CLUSTER1(SURFACE_CURRENT%SURFACE_FACES_NUM+1,30), BOUNDARY2(2,SURFACE_CURRENT%SURFACE_FACES_NUM), BOUNDARY_CLUSTER2(SURFACE_CURRENT%SURFACE_FACES_NUM+1,30))
    BOUNDARY1(:,:) = 0
    BOUNDARY_CLUSTER1(:,:) = 0
    BOUNDARY2(:,:) = 0
    BOUNDARY_CLUSTER2(:,:) = 0
    
    ALLOCATE(BOUNDARY_PAIR(2,30))
    BOUNDARY_PAIR(:,:) = 0
    
    DO I=1,REMOVE_PAIR_NUM
        CLUSTER_FLAG1 = REMOVE_PAIR(1,I)
        CLUSTER_FLAG2 = REMOVE_PAIR(2,I)
        
        IF(CLUSTER_FLAG1 .NE. CLUSTER_FLAG2) THEN
        
        CALL FIND_BOUNDARY_CLUSTER(TYP, REMOVE_CLUSTER_INDEX, CLUSTER_FLAG1, BOUNDARY_NUM1, BOUNDARY1, BOUNDARY_CLUSTER_NUM1, BOUNDARY_CLUSTER1)
        CALL FIND_BOUNDARY_CLUSTER(TYP, REMOVE_CLUSTER_INDEX, CLUSTER_FLAG2, BOUNDARY_NUM2, BOUNDARY2, BOUNDARY_CLUSTER_NUM2, BOUNDARY_CLUSTER2)
        
        CALL FIND_BOUNDARY_PAIR(TYP, CLUSTER_FLAG1, BOUNDARY1, BOUNDARY_CLUSTER_NUM1, BOUNDARY_CLUSTER1, CLUSTER_FLAG2, BOUNDARY2, BOUNDARY_CLUSTER_NUM2, BOUNDARY_CLUSTER2, BOUNDARY_PAIR_NUM, BOUNDARY_PAIR)
        
        ELSE
        
        CALL FIND_BOUNDARY_CLUSTER(TYP, REMOVE_CLUSTER_INDEX, CLUSTER_FLAG1, BOUNDARY_NUM1, BOUNDARY1, BOUNDARY_CLUSTER_NUM1, BOUNDARY_CLUSTER1)
        
        CALL FIND_BOUNDARY_PAIR(TYP, CLUSTER_FLAG1, BOUNDARY1, BOUNDARY_CLUSTER_NUM1, BOUNDARY_CLUSTER1, 0, BOUNDARY2, BOUNDARY_CLUSTER_NUM2, BOUNDARY_CLUSTER2, BOUNDARY_PAIR_NUM, BOUNDARY_PAIR)
        
        TEMP = 0
        
        END IF
    END DO
    
    DEALLOCATE(BOUNDARY_PAIR)
    
    DEALLOCATE(BOUNDARY1, BOUNDARY_CLUSTER1, BOUNDARY2, BOUNDARY_CLUSTER2)
    
    DEALLOCATE(REMOVE_PAIR)
    
    DEALLOCATE(REMOVE_CLUSTER, REMOVE_CLUSTER_INDEX)
    
    DEALLOCATE(B_REMOVE_FACE)
    
    END SUBROUTINE
    
    
    SUBROUTINE FIND_REMOVE_FACES(TYP, THRESHOLD, FLAG, B_REMOVE_FACE)
    IMPLICIT NONE
    INTEGER :: TYP
    REAL(8) :: THRESHOLD
    LOGICAL :: FLAG, B_REMOVE_FACE(:)
    
    INTEGER :: I, J, K, IPZ, DIR
    REAL(8) :: R
    LOGICAL :: B, TEMPFLAG
    LOGICAL, ALLOCATABLE :: TEMP_B_REMOVE_FACE(:), BEFORE_B_REMOVE_FACE(:)
    
    INTEGER :: BOUNDARY_NUM, I1
    LOGICAL :: C, D
    
    TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT
    
    IF (TYP==0) THEN
        SURFACE_CURRENT => SURFACE_FLUID
    END IF
    IF (TYP==1) THEN
        SURFACE_CURRENT => SURFACE_PROPEL
    END IF
    IF (TYP==2) THEN
        SURFACE_CURRENT => SURFACE_CASE
    END IF

    FLAG = .FALSE.
    B_REMOVE_FACE(:) = .FALSE.

    TEMPFLAG = .FALSE.

    B = .TRUE.
    DIR = 0

    DO I=1,SURFACE_CURRENT%SURFACE_FACES_NUM
        IPZ = SURFACE_CURRENT%FACE_IMPACT_ZONE(TYP+1, I)
        IF(IPZ.NE.0) THEN
            CALL DISTANCE_FACE_FACE_TYPE(I,TYP,IPZ,TYP,DIR,  R,B)
            IF(R < THRESHOLD) THEN
                TEMPFLAG = .TRUE.
                EXIT
            END IF
        END IF
    END DO

    IF(TEMPFLAG) THEN

    ALLOCATE(TEMP_B_REMOVE_FACE(SURFACE_CURRENT%SURFACE_FACES_NUM), BEFORE_B_REMOVE_FACE(SURFACE_CURRENT%SURFACE_FACES_NUM))
    B_REMOVE_FACE(:) = .FALSE.

    DO I=1,SURFACE_CURRENT%SURFACE_FACES_NUM
        IPZ = SURFACE_CURRENT%FACE_IMPACT_ZONE(TYP+1, I)
        IF(IPZ.NE.0) THEN
            CALL DISTANCE_FACE_FACE_TYPE(I,TYP,IPZ,TYP,DIR,  R,B)
            IF(R < THRESHOLD * 1.5) THEN
                B_REMOVE_FACE(I) = .TRUE.
            END IF
        END IF
    END DO
    
    CALL TEST_SAVINGDATA_TECPLOT(1000, SURFACE_CURRENT%SURFACE_POINTS_NUM, SURFACE_CURRENT%SURFACE_POINTS, SURFACE_CURRENT%SURFACE_FACES_NUM, SURFACE_CURRENT%SURFACE_FACES, SURFACE_CURRENT%FACE_DIVIDED_REGION_ARRAY, SURFACE_CURRENT%FACE_DIVIDED_BOUNDARY_ARRAY, B_REMOVE_FACE)
    
    
    B = .TRUE.
    
    DO WHILE(B)
    
    B = .FALSE.
    
    DO I=1,SURFACE_CURRENT%SURFACE_FACES_NUM
        IF(B_REMOVE_FACE(I) .AND. SURFACE_CURRENT%FACE_ONINTERFACE(I).NE.-1) THEN
            BOUNDARY_NUM = 0
            DO K=1,3
                CALL FACE_NEIGHBOR_FACE(SURFACE_CURRENT%SURFACE_FACES, SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM, SURFACE_CURRENT%POINT_FACE_CONNECTION,I,K, I1)
                IF(.NOT. B_REMOVE_FACE(I1) .AND. SURFACE_CURRENT%FACE_ONINTERFACE(I1).NE.-1) THEN
                    BOUNDARY_NUM = BOUNDARY_NUM + 1
                END IF
            END DO
            IF(BOUNDARY_NUM >= 2) THEN
                B = .TRUE.
                B_REMOVE_FACE(I) = .FALSE.
            END IF
        END IF
    END DO
    
    END DO
    
    CALL TEST_SAVINGDATA_TECPLOT(2000, SURFACE_CURRENT%SURFACE_POINTS_NUM, SURFACE_CURRENT%SURFACE_POINTS, SURFACE_CURRENT%SURFACE_FACES_NUM, SURFACE_CURRENT%SURFACE_FACES, SURFACE_CURRENT%FACE_DIVIDED_REGION_ARRAY, SURFACE_CURRENT%FACE_DIVIDED_BOUNDARY_ARRAY, B_REMOVE_FACE)
    
    B = .TRUE.
    
    DO WHILE(B)
    
    B = .FALSE.
    
    BEFORE_B_REMOVE_FACE(:) = B_REMOVE_FACE(:)
    TEMP_B_REMOVE_FACE(:) = B_REMOVE_FACE(:)
    
    DO I=1,SURFACE_CURRENT%SURFACE_POINTS_NUM
        C = .FALSE.
        D = .FALSE.
        DO J=1,SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(I)
            I1 = SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I)
            IF(B_REMOVE_FACE(I1)) THEN
                C = .TRUE.
            ELSE IF(.NOT. B_REMOVE_FACE(I1) .AND. SURFACE_CURRENT%FACE_ONINTERFACE(I1).NE.-1) THEN
                D = .TRUE.
            END IF
        END DO
        
        IF(C .AND. D) THEN
        
        DO J=1,SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(I)
            I1 = SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I)
            IF(.NOT. B_REMOVE_FACE(I1) .AND. SURFACE_CURRENT%FACE_ONINTERFACE(I1).NE.-1) THEN
                TEMP_B_REMOVE_FACE(I1) = .TRUE.
            END IF
        END DO
        
        END IF
    END DO
    
    B_REMOVE_FACE(:) = TEMP_B_REMOVE_FACE(:)
    
    DO I=1,SURFACE_CURRENT%SURFACE_POINTS_NUM
        C = .FALSE.
        D = .FALSE.
        DO J=1,SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(I)
            I1 = SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I)
            IF(B_REMOVE_FACE(I1) .AND. SURFACE_CURRENT%FACE_ONINTERFACE(I1).NE.-1) THEN
                C = .TRUE.
            ELSE IF(.NOT. B_REMOVE_FACE(I1) .AND. SURFACE_CURRENT%FACE_ONINTERFACE(I1).NE.-1) THEN
                D = .TRUE.
            END IF
        END DO
        
        IF(C .AND. D) THEN
        
        DO J=1,SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(I)
            I1 = SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I)
            IF(B_REMOVE_FACE(I1) .AND. SURFACE_CURRENT%FACE_ONINTERFACE(I1).NE.-1) THEN
                TEMP_B_REMOVE_FACE(I1) = .FALSE.
            END IF
        END DO
        
        END IF
    END DO
    
    B_REMOVE_FACE(:) = TEMP_B_REMOVE_FACE(:)
    
    DO I=1,SURFACE_CURRENT%SURFACE_FACES_NUM
        IF(B_REMOVE_FACE(I) .NE. BEFORE_B_REMOVE_FACE(I)) THEN
            B = .TRUE.
            EXIT
        END IF
    END DO
    
    END DO
    
    CALL TEST_SAVINGDATA_TECPLOT(3000, SURFACE_CURRENT%SURFACE_POINTS_NUM, SURFACE_CURRENT%SURFACE_POINTS, SURFACE_CURRENT%SURFACE_FACES_NUM, SURFACE_CURRENT%SURFACE_FACES, SURFACE_CURRENT%FACE_DIVIDED_REGION_ARRAY, SURFACE_CURRENT%FACE_DIVIDED_BOUNDARY_ARRAY, B_REMOVE_FACE)
    
    B = .TRUE.
    
    DO WHILE(B)
    
    B = .FALSE.
    
    DO I=1,SURFACE_CURRENT%SURFACE_FACES_NUM
        IF(B_REMOVE_FACE(I) .AND. SURFACE_CURRENT%FACE_ONINTERFACE(I).NE.-1) THEN
            BOUNDARY_NUM = 0
            DO K=1,3
                CALL FACE_NEIGHBOR_FACE(SURFACE_CURRENT%SURFACE_FACES, SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM, SURFACE_CURRENT%POINT_FACE_CONNECTION,I,K, I1)
                IF(.NOT. B_REMOVE_FACE(I1) .AND. SURFACE_CURRENT%FACE_ONINTERFACE(I1).NE.-1) THEN
                    BOUNDARY_NUM = BOUNDARY_NUM + 1
                END IF
            END DO
            IF(BOUNDARY_NUM >= 2) THEN
                B = .TRUE.
                B_REMOVE_FACE(I) = .FALSE.
            END IF
        END IF
    END DO
    
    END DO
    
    CALL TEST_SAVINGDATA_TECPLOT(4000, SURFACE_CURRENT%SURFACE_POINTS_NUM, SURFACE_CURRENT%SURFACE_POINTS, SURFACE_CURRENT%SURFACE_FACES_NUM, SURFACE_CURRENT%SURFACE_FACES, SURFACE_CURRENT%FACE_DIVIDED_REGION_ARRAY, SURFACE_CURRENT%FACE_DIVIDED_BOUNDARY_ARRAY, B_REMOVE_FACE)
    
    IF(TYP==1) THEN
        DO I=1,SURFACE_CURRENT%SURFACE_FACES_NUM/2
            IF(.NOT. B_REMOVE_FACE(2*I-1) .OR. .NOT. B_REMOVE_FACE(2*I)) THEN
                B_REMOVE_FACE(2*I-1) = .FALSE.
                B_REMOVE_FACE(2*I) = .FALSE.
            END IF
        END DO
    END IF
    
    CALL TEST_SAVINGDATA_TECPLOT(5000, SURFACE_CURRENT%SURFACE_POINTS_NUM, SURFACE_CURRENT%SURFACE_POINTS, SURFACE_CURRENT%SURFACE_FACES_NUM, SURFACE_CURRENT%SURFACE_FACES, SURFACE_CURRENT%FACE_DIVIDED_REGION_ARRAY, SURFACE_CURRENT%FACE_DIVIDED_BOUNDARY_ARRAY, B_REMOVE_FACE)
    
    DEALLOCATE(TEMP_B_REMOVE_FACE, BEFORE_B_REMOVE_FACE)
    
    END IF

    !DEALLOCATE(PATCH_PARENT)

    END SUBROUTINE
    
    
    SUBROUTINE FIND_REMOVE_CLUSTERS(TYP, B_REMOVE_FACE, REMOVE_CLUSTER_NUM, REMOVE_CLUSTER, REMOVE_CLUSTER_INDEX)
    IMPLICIT NONE
    INTEGER :: TYP
    LOGICAL :: B_REMOVE_FACE(:)
    INTEGER :: REMOVE_CLUSTER_NUM
    INTEGER :: REMOVE_CLUSTER(:,:)
    INTEGER :: REMOVE_CLUSTER_INDEX(:)
    
    INTEGER :: CURRENT_CLUSTER_NUM, TEMP_CLUSTER_NUM
    
    LOGICAL, ALLOCATABLE :: USED_FACE(:)
    
    INTEGER :: I, K, I0, I1
    LOGICAL :: B, C
    
    TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT
    
    IF (TYP==0) THEN
        SURFACE_CURRENT => SURFACE_FLUID
    END IF
    IF (TYP==1) THEN
        SURFACE_CURRENT => SURFACE_PROPEL
    END IF
    IF (TYP==2) THEN
        SURFACE_CURRENT => SURFACE_CASE
    END IF
    
    REMOVE_CLUSTER_NUM = 0
    REMOVE_CLUSTER(:,:) = 0
    REMOVE_CLUSTER_INDEX(:) = 0
    
    ALLOCATE(USED_FACE(SURFACE_CURRENT%SURFACE_FACES_NUM))
    USED_FACE(:) = .NOT. B_REMOVE_FACE(:)
    
    C = .TRUE.
    DO WHILE(C)
        C = .FALSE.
        DO I=1,SURFACE_CURRENT%SURFACE_FACES_NUM
            IF(.NOT. USED_FACE(I)) THEN
                C = .TRUE.
                EXIT
            END IF
        END DO
        
        IF(C) THEN
        
        REMOVE_CLUSTER_NUM = REMOVE_CLUSTER_NUM + 1
        REMOVE_CLUSTER(1,REMOVE_CLUSTER_NUM) = I
        REMOVE_CLUSTER_INDEX(I) = REMOVE_CLUSTER_NUM
        USED_FACE(I) = .TRUE.
        CURRENT_CLUSTER_NUM = 1
        TEMP_CLUSTER_NUM = 1
        
        B = .TRUE.
        DO WHILE(B)
            B = .FALSE.
            
            DO I = 1,CURRENT_CLUSTER_NUM
                I0 = REMOVE_CLUSTER(I,REMOVE_CLUSTER_NUM)
                
                DO K=1,3
                    CALL FACE_NEIGHBOR_FACE(SURFACE_CURRENT%SURFACE_FACES, SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM, SURFACE_CURRENT%POINT_FACE_CONNECTION,I0,K, I1)
                    
                    IF(.NOT. USED_FACE(I1)) THEN
                        B = .TRUE.
                        TEMP_CLUSTER_NUM = TEMP_CLUSTER_NUM + 1
                        REMOVE_CLUSTER(TEMP_CLUSTER_NUM, REMOVE_CLUSTER_NUM) = I1
                        REMOVE_CLUSTER_INDEX(I1) = REMOVE_CLUSTER_NUM
                        USED_FACE(I1) = .TRUE.
                    END IF
                END DO
            END DO
            
            CURRENT_CLUSTER_NUM = TEMP_CLUSTER_NUM
            
        END DO
        
        IF(CURRENT_CLUSTER_NUM < 10) THEN
            REMOVE_CLUSTER(1:CURRENT_CLUSTER_NUM, REMOVE_CLUSTER_NUM) = 0
            
            DO I=1,SURFACE_CURRENT%SURFACE_FACES_NUM
                IF(REMOVE_CLUSTER_INDEX(I)==REMOVE_CLUSTER_NUM) REMOVE_CLUSTER_INDEX(I) = 0
            END DO
            
            REMOVE_CLUSTER_NUM = REMOVE_CLUSTER_NUM - 1
        END IF
        
        END IF
    END DO
    
    DEALLOCATE(USED_FACE)
    
    END SUBROUTINE
    
    
    SUBROUTINE FIND_REMOVE_PAIRS(TYP, REMOVE_CLUSTER_NUM, REMOVE_CLUSTER, REMOVE_CLUSTER_INDEX, REMOVE_PAIR_NUM, REMOVE_PAIR)
    IMPLICIT NONE
    INTEGER :: TYP
    INTEGER :: REMOVE_CLUSTER_NUM
    INTEGER :: REMOVE_CLUSTER(:,:)
    INTEGER :: REMOVE_CLUSTER_INDEX(:)
    INTEGER :: REMOVE_PAIR_NUM
    INTEGER :: REMOVE_PAIR(:,:)
    
    INTEGER :: I, ITER, IPZ, I1
    LOGICAL :: B
    
    TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT
    
    IF (TYP==0) THEN
        SURFACE_CURRENT => SURFACE_FLUID
    END IF
    IF (TYP==1) THEN
        SURFACE_CURRENT => SURFACE_PROPEL
    END IF
    IF (TYP==2) THEN
        SURFACE_CURRENT => SURFACE_CASE
    END IF
    
    REMOVE_PAIR_NUM = 0
    REMOVE_PAIR(:,:) = 0
    
    DO ITER=1,REMOVE_CLUSTER_NUM
        
        B = .TRUE.
        
        DO I = 1,REMOVE_PAIR_NUM
            IF(REMOVE_PAIR(1,I)==ITER .OR. REMOVE_PAIR(2,I)==ITER) THEN
                B = .FALSE.
                EXIT
            END IF
        END DO
        
        IF(B) THEN
        
        I = 1
        DO WHILE(REMOVE_CLUSTER(I,ITER) .NE. 0)
            I1 = REMOVE_CLUSTER(I,ITER)
            IPZ = SURFACE_CURRENT%FACE_IMPACT_ZONE(TYP+1, I1)
            
            IF(REMOVE_CLUSTER_INDEX(IPZ) .NE. 0) THEN
                REMOVE_PAIR_NUM = REMOVE_PAIR_NUM + 1
                REMOVE_PAIR(1,REMOVE_PAIR_NUM) = ITER
                REMOVE_PAIR(2,REMOVE_PAIR_NUM) = REMOVE_CLUSTER_INDEX(IPZ)
                EXIT
            END IF
            
            I = I + 1
        END DO
        
        END IF
    END DO
    
    END SUBROUTINE
    
    SUBROUTINE FIND_BOUNDARY_CLUSTER(TYP, REMOVE_CLUSTER_INDEX, CLUSTER_FLAG, BOUNDARY_NUM, BOUNDARY, BOUNDARY_CLUSTER_NUM, BOUNDARY_CLUSTER)
    IMPLICIT NONE
    INTEGER :: TYP
    INTEGER :: REMOVE_CLUSTER_INDEX(:)
    INTEGER :: CLUSTER_FLAG
    
    INTEGER :: BOUNDARY_NUM
    INTEGER :: BOUNDARY(:,:)
    
    INTEGER :: BOUNDARY_CLUSTER_NUM
    INTEGER :: BOUNDARY_CLUSTER(:,:)
    
    INTEGER, ALLOCATABLE :: BOUNDARY_INDEX(:,:)
    
    LOGICAL, ALLOCATABLE :: USED_BOUNDARY(:)
    
    INTEGER :: CURRENT_CLUSTER_NUM
    INTEGER :: I,K,L,T,I0,K0,I1,J1, ITER
    LOGICAL :: B,C
    
    TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT
    
    IF (TYP==0) THEN
        SURFACE_CURRENT => SURFACE_FLUID
    END IF
    IF (TYP==1) THEN
        SURFACE_CURRENT => SURFACE_PROPEL
    END IF
    IF (TYP==2) THEN
        SURFACE_CURRENT => SURFACE_CASE
    END IF
    
    ALLOCATE(BOUNDARY_INDEX(3,SURFACE_CURRENT%SURFACE_FACES_NUM))
    BOUNDARY_NUM = 0
    BOUNDARY(:,:) = 0
    BOUNDARY_INDEX(:,:) = 0
    
    DO I=1,SURFACE_CURRENT%SURFACE_FACES_NUM
        
        IF(REMOVE_CLUSTER_INDEX(I)==CLUSTER_FLAG) THEN
        
        DO K=1,3
            CALL FACE_NEIGHBOR_FACE(SURFACE_CURRENT%SURFACE_FACES, SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM, SURFACE_CURRENT%POINT_FACE_CONNECTION,I,K, I1)
            
            IF(REMOVE_CLUSTER_INDEX(I1) .NE. CLUSTER_FLAG) THEN
                BOUNDARY_NUM = BOUNDARY_NUM + 1
                BOUNDARY(1,BOUNDARY_NUM) = I
                BOUNDARY(2,BOUNDARY_NUM) = K
                
                BOUNDARY_INDEX(K,I) = BOUNDARY_NUM
                
                DO L=1,3
                    IF(SURFACE_CURRENT%SURFACE_FACES(K,I) == SURFACE_CURRENT%SURFACE_FACES(MOD(L,3)+1,I1)) THEN
                        EXIT
                    END IF
                END DO
                
                BOUNDARY_INDEX(L,I1) = BOUNDARY_NUM
            END IF
        END DO
        
        END IF
    END DO
    
    ALLOCATE(USED_BOUNDARY(BOUNDARY_NUM))
    USED_BOUNDARY(:) = .FALSE.
    BOUNDARY_CLUSTER_NUM = 0
    BOUNDARY_CLUSTER(:,:) = 0
    
    C = .TRUE.
    DO WHILE(C)
        C = .FALSE.
        DO ITER=1,BOUNDARY_NUM
            IF(.NOT. USED_BOUNDARY(ITER)) THEN
                C = .TRUE.
                EXIT
            END IF
        END DO
        
        IF(C) THEN
        
        BOUNDARY_CLUSTER_NUM = BOUNDARY_CLUSTER_NUM + 1
!        BOUNDARY_CLUSTER(1,BOUNDARY_CLUSTER_NUM) = ITER
        BOUNDARY_CLUSTER(SURFACE_CURRENT%SURFACE_FACES_NUM,BOUNDARY_CLUSTER_NUM) = ITER
        USED_BOUNDARY(ITER) = .TRUE.
        CURRENT_CLUSTER_NUM = 1
        
        B = .TRUE.
        DO WHILE(B)
            B = .FALSE.
            
            ITER = BOUNDARY_CLUSTER(SURFACE_CURRENT%SURFACE_FACES_NUM+1 - CURRENT_CLUSTER_NUM, BOUNDARY_CLUSTER_NUM)
            I0 = BOUNDARY(1,ITER)
            K0 = BOUNDARY(2,ITER)
            
            J1 = SURFACE_CURRENT%SURFACE_FACES(K0,I0)
            
            DO T=1,SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(J1)
                I1 = SURFACE_CURRENT%POINT_FACE_CONNECTION(T,J1)
                
                DO L=1,3
                    IF(J1 == SURFACE_CURRENT%SURFACE_FACES(L,I1)) THEN
                        EXIT
                    END IF
                END DO
                
                IF(BOUNDARY_INDEX(L,I1) .NE. ITER .AND. BOUNDARY_INDEX(L,I1) .NE. 0) THEN
                    EXIT
                END IF
            END DO
            
            IF(.NOT. USED_BOUNDARY(BOUNDARY_INDEX(L,I1)) .AND. SURFACE_CURRENT%FACE_DIVIDED_BOUNDARY_ARRAY(L,I1) == SURFACE_CURRENT%FACE_DIVIDED_BOUNDARY_ARRAY(K0,I0)) THEN
                B = .TRUE.
                CURRENT_CLUSTER_NUM = CURRENT_CLUSTER_NUM + 1
                BOUNDARY_CLUSTER(SURFACE_CURRENT%SURFACE_FACES_NUM+1 - CURRENT_CLUSTER_NUM, BOUNDARY_CLUSTER_NUM) = BOUNDARY_INDEX(L,I1)
                
                USED_BOUNDARY(BOUNDARY_INDEX(L,I1)) = .TRUE.
            END IF
            
        END DO
        
        DO I=1,CURRENT_CLUSTER_NUM
            BOUNDARY_CLUSTER(I,BOUNDARY_CLUSTER_NUM) = BOUNDARY_CLUSTER(SURFACE_CURRENT%SURFACE_FACES_NUM - CURRENT_CLUSTER_NUM + I,BOUNDARY_CLUSTER_NUM)
        END DO
        
        B = .TRUE.
        DO WHILE(B)
            B = .FALSE.
            
            ITER = BOUNDARY_CLUSTER(CURRENT_CLUSTER_NUM, BOUNDARY_CLUSTER_NUM)
            I0 = BOUNDARY(1,ITER)
            K0 = BOUNDARY(2,ITER)
            
            J1 = SURFACE_CURRENT%SURFACE_FACES(MOD(K0,3)+1,I0)
            
            DO T=1,SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(J1)
                I1 = SURFACE_CURRENT%POINT_FACE_CONNECTION(T,J1)
                
                DO L=1,3
                    IF(J1 == SURFACE_CURRENT%SURFACE_FACES(L,I1)) THEN
                        EXIT
                    END IF
                END DO
                
                IF(BOUNDARY_INDEX(L,I1) .NE. ITER .AND. BOUNDARY_INDEX(L,I1) .NE. 0) THEN
                    EXIT
                END IF
            END DO
            
            IF(.NOT. USED_BOUNDARY(BOUNDARY_INDEX(L,I1)) .AND. SURFACE_CURRENT%FACE_DIVIDED_BOUNDARY_ARRAY(L,I1) == SURFACE_CURRENT%FACE_DIVIDED_BOUNDARY_ARRAY(K0,I0)) THEN
                B = .TRUE.
                CURRENT_CLUSTER_NUM = CURRENT_CLUSTER_NUM + 1
                BOUNDARY_CLUSTER(CURRENT_CLUSTER_NUM, BOUNDARY_CLUSTER_NUM) = BOUNDARY_INDEX(L,I1)
                
                USED_BOUNDARY(BOUNDARY_INDEX(L,I1)) = .TRUE.
            END IF
            
        END DO
        
        END IF
    END DO
    
    
    DEALLOCATE(USED_BOUNDARY)
    
    DEALLOCATE(BOUNDARY_INDEX)
    
    END SUBROUTINE
    
    
    SUBROUTINE FIND_BOUNDARY_PAIR(TYP, CLUSTER_FLAG1, BOUNDARY1, BOUNDARY_CLUSTER_NUM1, BOUNDARY_CLUSTER1, CLUSTER_FLAG2, BOUNDARY2, BOUNDARY_CLUSTER_NUM2, BOUNDARY_CLUSTER2, BOUNDARY_PAIR_NUM, BOUNDARY_PAIR)
    IMPLICIT NONE
    INTEGER :: TYP
    
    INTEGER :: CLUSTER_FLAG1
    INTEGER :: BOUNDARY1(:,:)
    INTEGER :: BOUNDARY_CLUSTER_NUM1
    INTEGER :: BOUNDARY_CLUSTER1(:,:)
    
    INTEGER :: CLUSTER_FLAG2
    INTEGER :: BOUNDARY2(:,:)
    INTEGER :: BOUNDARY_CLUSTER_NUM2
    INTEGER :: BOUNDARY_CLUSTER2(:,:)
    
    INTEGER :: BOUNDARY_PAIR_NUM
    INTEGER :: BOUNDARY_PAIR(:,:)
    
    INTEGER, ALLOCATABLE :: BOUNDARY_CLUSTER_INDEX(:,:)
    
    INTEGER :: I,K,L,I0,K0,I1,IPZ, ITER
    LOGICAL :: B
    
    TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT
    
    IF (TYP==0) THEN
        SURFACE_CURRENT => SURFACE_FLUID
    END IF
    IF (TYP==1) THEN
        SURFACE_CURRENT => SURFACE_PROPEL
    END IF
    IF (TYP==2) THEN
        SURFACE_CURRENT => SURFACE_CASE
    END IF
    
    
    ALLOCATE(BOUNDARY_CLUSTER_INDEX(3,SURFACE_CURRENT%SURFACE_FACES_NUM))
    
    IF(CLUSTER_FLAG2 .NE. 0) THEN
    
    DO ITER=1,BOUNDARY_CLUSTER_NUM2
        I = 1
        DO WHILE(BOUNDARY_CLUSTER2(I,ITER) .NE. 0)
            I0 = BOUNDARY2(1,BOUNDARY_CLUSTER2(I,ITER))
            K0 = BOUNDARY2(2,BOUNDARY_CLUSTER2(I,ITER))
            
            BOUNDARY_CLUSTER_INDEX(K0,I0) = ITER
            
            CALL FACE_NEIGHBOR_FACE(SURFACE_CURRENT%SURFACE_FACES, SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM, SURFACE_CURRENT%POINT_FACE_CONNECTION,I0,K0, I1)
            DO L=1,3
                IF(SURFACE_CURRENT%SURFACE_FACES(K0,I0) == SURFACE_CURRENT%SURFACE_FACES(MOD(L,3)+1,I1)) THEN
                    EXIT
                END IF
            END DO
            
            BOUNDARY_CLUSTER_INDEX(L,I1) = ITER
            
            I = I+1
        END DO
    END DO
    
    ELSE
    
    DO ITER=1,BOUNDARY_CLUSTER_NUM1
        I = 1
        DO WHILE(BOUNDARY_CLUSTER1(I,ITER) .NE. 0)
            I0 = BOUNDARY1(1,BOUNDARY_CLUSTER1(I,ITER))
            K0 = BOUNDARY1(2,BOUNDARY_CLUSTER1(I,ITER))
            
            BOUNDARY_CLUSTER_INDEX(K0,I0) = ITER
            
            CALL FACE_NEIGHBOR_FACE(SURFACE_CURRENT%SURFACE_FACES, SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM, SURFACE_CURRENT%POINT_FACE_CONNECTION,I0,K0, I1)
            DO L=1,3
                IF(SURFACE_CURRENT%SURFACE_FACES(K0,I0) == SURFACE_CURRENT%SURFACE_FACES(MOD(L,3)+1,I1)) THEN
                    EXIT
                END IF
            END DO
            
            BOUNDARY_CLUSTER_INDEX(L,I1) = ITER
            
            I = I+1
        END DO
    END DO
    
    END IF
    
    BOUNDARY_PAIR_NUM = 0
    BOUNDARY_PAIR(:,:) = 0
    
    DO ITER=1,BOUNDARY_CLUSTER_NUM1
        
        B = .TRUE.
        
        IF(CLUSTER_FLAG2 .NE. 0) THEN
        
        DO I = 1,BOUNDARY_PAIR_NUM
            IF(BOUNDARY_PAIR(1,I)==ITER) THEN
                B = .FALSE.
                EXIT
            END IF
        END DO
        
        ELSE
        
        DO I = 1,BOUNDARY_PAIR_NUM
            IF(BOUNDARY_PAIR(1,I)==ITER .OR. BOUNDARY_PAIR(2,I)==ITER) THEN
                B = .FALSE.
                EXIT
            END IF
        END DO
        
        END IF
        
        IF(B) THEN
        
        I = 1
        DO WHILE(BOUNDARY_CLUSTER1(I,ITER) .NE. 0)
            I0 = BOUNDARY1(1,BOUNDARY_CLUSTER1(I,ITER))
            K0 = BOUNDARY1(2,BOUNDARY_CLUSTER1(I,ITER))
            
            IPZ = SURFACE_CURRENT%FACE_IMPACT_ZONE(TYP+1, I0)
            
            DO K=1,3
            IF(BOUNDARY_CLUSTER_INDEX(K,IPZ) .NE. 0) THEN
                BOUNDARY_PAIR_NUM = BOUNDARY_PAIR_NUM + 1
                BOUNDARY_PAIR(1,BOUNDARY_PAIR_NUM) = ITER
                BOUNDARY_PAIR(2,BOUNDARY_PAIR_NUM) = BOUNDARY_CLUSTER_INDEX(K,IPZ)
                EXIT
            END IF
            END DO
            
            I = I + 1
        END DO
        
        END IF
    END DO
    
    DEALLOCATE(BOUNDARY_CLUSTER_INDEX)
    
    END SUBROUTINE
    
    
    SUBROUTINE REMOVE_CERTAIN_FACES(TYP, B_REMOVE_FACE)
    IMPLICIT NONE
    
    INTEGER :: TYP
    LOGICAL :: B_REMOVE_FACE(:)
    
    INTEGER :: I, J
    LOGICAL :: B
    INTEGER :: NEWPOINT_NUM, NEWFACE_NUM
    REAL(8), ALLOCATABLE :: NEWPOINT(:,:) 
    INTEGER, ALLOCATABLE :: NEWFACE(:,:)
    INTEGER, ALLOCATABLE :: POINT_INDEX(:)
    INTEGER, ALLOCATABLE :: FACE_INDEX(:)
    
    TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT
    
    IF (TYP==0) THEN
        SURFACE_CURRENT => SURFACE_FLUID
    END IF
    IF (TYP==1) THEN
        SURFACE_CURRENT => SURFACE_PROPEL
    END IF
    IF (TYP==2) THEN
        SURFACE_CURRENT => SURFACE_CASE
    END IF
    
    ALLOCATE(NEWPOINT(3,SURFACE_CURRENT%SURFACE_POINTS_NUM))
    ALLOCATE(NEWFACE(3,SURFACE_CURRENT%SURFACE_FACES_NUM))
    ALLOCATE(POINT_INDEX(SURFACE_CURRENT%SURFACE_POINTS_NUM))
    ALLOCATE(FACE_INDEX(SURFACE_CURRENT%SURFACE_FACES_NUM))

    POINT_INDEX(:) = 0
    FACE_INDEX(:) = 0

    NEWPOINT_NUM = 0

    DO I = 1, SURFACE_CURRENT%SURFACE_POINTS_NUM
        B = .FALSE.
        DO J = 1, SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(I)
            IF(.NOT. B_REMOVE_FACE(SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I))) THEN
                B = .TRUE.
            END IF
        END DO
        
        IF(B) THEN
            NEWPOINT_NUM = NEWPOINT_NUM+1
            NEWPOINT(:,NEWPOINT_NUM) = SURFACE_CURRENT%SURFACE_POINTS(:,I)
            POINT_INDEX(I) = NEWPOINT_NUM
        END IF
    END DO

    NEWFACE_NUM = 0

    DO J = 1, SURFACE_CURRENT%SURFACE_FACES_NUM
        IF(.NOT. B_REMOVE_FACE(J)) THEN
            NEWFACE_NUM = NEWFACE_NUM+1
            NEWFACE(:,NEWFACE_NUM) = SURFACE_CURRENT%SURFACE_FACES(:,J)
            FACE_INDEX(J) = NEWFACE_NUM
        END IF
    END DO

    CALL NEW_POINTFACE_INDEX(TYP, NEWPOINT_NUM, NEWPOINT, NEWFACE_NUM, NEWFACE, POINT_INDEX, FACE_INDEX)

    !IF(TYP==1) THEN
    !    CALL CLASSIFY_PATCH(1)
    !END IF

    DEALLOCATE(NEWPOINT)
    DEALLOCATE(NEWFACE)
    DEALLOCATE(POINT_INDEX)
    DEALLOCATE(FACE_INDEX)
    
    END SUBROUTINE
    
    END MODULE
