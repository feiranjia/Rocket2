    MODULE TOPCHANGE_3D
    USE SURFACE_MODULE_3D
    USE SURFACES_3D
    USE REMESHING_3D
    
    IMPLICIT NONE

    CONTAINS
    
    
    SUBROUTINE TEST_ZIPPER(TYP, FLAG)
    IMPLICIT NONE
    INTEGER :: TYP
    LOGICAL :: FLAG
    
    REAL(8) :: THRESHOLD
    
    LOGICAL, ALLOCATABLE :: B_REMOVE_FACE(:)
    INTEGER :: REMOVE_CLUSTER_NUM
    INTEGER, ALLOCATABLE :: REMOVE_CLUSTER(:,:)
    INTEGER, ALLOCATABLE :: REMOVE_CLUSTER_INDEX(:)
    INTEGER :: REMOVE_PAIR_NUM
    INTEGER, ALLOCATABLE :: REMOVE_PAIR(:,:)
    
    INTEGER :: CLUSTER_FLAG1
    INTEGER :: BOUNDARY_CLUSTER_NUM1
    INTEGER, ALLOCATABLE :: BOUNDARY_CLUSTER1(:,:)
    
    INTEGER :: CLUSTER_FLAG2
    INTEGER :: BOUNDARY_CLUSTER_NUM2
    INTEGER, ALLOCATABLE :: BOUNDARY_CLUSTER2(:,:)
    
    INTEGER :: BOUNDARY_PAIR_NUM
    INTEGER, ALLOCATABLE :: BOUNDARY_PAIR(:,:)
    
    INTEGER :: CORNER_PAIR_NUM
    INTEGER, ALLOCATABLE :: CORNER_PAIR(:,:)
    
    INTEGER, ALLOCATABLE :: CORNER_CONNECTION_CLUSTER(:,:)
    
    INTEGER :: BOUNDARY_ZIPPER_POINT_NUM1
    INTEGER, ALLOCATABLE :: BOUNDARY_ZIPPER_POINT1(:)
    
    INTEGER :: BOUNDARY_ZIPPER_POINT_NUM2
    INTEGER, ALLOCATABLE :: BOUNDARY_ZIPPER_POINT2(:)
    
    INTEGER :: I, J, TEMP
    LOGICAL :: B
    
    TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT
    
    IF (TYP==0) THEN
        SURFACE_CURRENT => SURFACE_FLUID
    END IF
    IF (TYP==1) THEN
        SURFACE_CURRENT => SURFACE_PROPEL
    END IF
    IF (TYP==2) THEN
        SURFACE_CURRENT => SURFACE_CASE
    END IF

    
    ALLOCATE(B_REMOVE_FACE(2*SURFACE_CURRENT%SURFACE_FACES_NUM))
    B_REMOVE_FACE(:) = .FALSE.
    
    THRESHOLD = SURFACE_FLUID%MESH_SIZE * 45.
    
    CALL FIND_REMOVE_FACES(TYP, THRESHOLD, FLAG, B_REMOVE_FACE)
   
    ALLOCATE(REMOVE_CLUSTER(SURFACE_CURRENT%SURFACE_FACES_NUM +1,10), REMOVE_CLUSTER_INDEX(SURFACE_CURRENT%SURFACE_FACES_NUM))
    REMOVE_CLUSTER(:,:) = 0
    REMOVE_CLUSTER_INDEX(:) = 0
    
    CALL FIND_REMOVE_CLUSTERS(TYP, B_REMOVE_FACE, REMOVE_CLUSTER_NUM, REMOVE_CLUSTER, REMOVE_CLUSTER_INDEX)
    
    ALLOCATE(REMOVE_PAIR(2,10))
    REMOVE_PAIR(:,:) = 0
    
    CALL FIND_REMOVE_PAIRS(TYP, REMOVE_CLUSTER_NUM, REMOVE_CLUSTER, REMOVE_CLUSTER_INDEX, REMOVE_PAIR_NUM, REMOVE_PAIR)
    
    ALLOCATE(BOUNDARY_CLUSTER1(SURFACE_CURRENT%SURFACE_FACES_NUM+1,30), BOUNDARY_CLUSTER2(SURFACE_CURRENT%SURFACE_FACES_NUM+1,30))
    BOUNDARY_CLUSTER1(:,:) = 0
    BOUNDARY_CLUSTER2(:,:) = 0
    
    ALLOCATE(BOUNDARY_PAIR(2,30))
    BOUNDARY_PAIR(:,:) = 0
    
    ALLOCATE(CORNER_PAIR(2,30))
    CORNER_PAIR(:,:) = 0
    
    ALLOCATE(CORNER_CONNECTION_CLUSTER(SURFACE_CURRENT%SURFACE_POINTS_NUM, 30))
    
    ALLOCATE(BOUNDARY_ZIPPER_POINT1(SURFACE_CURRENT%SURFACE_POINTS_NUM), BOUNDARY_ZIPPER_POINT2(SURFACE_CURRENT%SURFACE_POINTS_NUM))
    BOUNDARY_ZIPPER_POINT1(:) = 0
    BOUNDARY_ZIPPER_POINT2(:) = 0
    
    DO I=1,REMOVE_PAIR_NUM
        CLUSTER_FLAG1 = REMOVE_PAIR(1,I)
        CLUSTER_FLAG2 = REMOVE_PAIR(2,I)
        
        IF(CLUSTER_FLAG1 .NE. CLUSTER_FLAG2) THEN
        
        CALL FIND_BOUNDARY_CLUSTER(TYP, REMOVE_CLUSTER_INDEX, CLUSTER_FLAG1, BOUNDARY_CLUSTER_NUM1, BOUNDARY_CLUSTER1)
        CALL FIND_BOUNDARY_CLUSTER(TYP, REMOVE_CLUSTER_INDEX, CLUSTER_FLAG2, BOUNDARY_CLUSTER_NUM2, BOUNDARY_CLUSTER2)
        
        ELSE
        
        CALL FIND_BOUNDARY_CLUSTER(TYP, REMOVE_CLUSTER_INDEX, CLUSTER_FLAG1, BOUNDARY_CLUSTER_NUM1, BOUNDARY_CLUSTER1)
        BOUNDARY_CLUSTER_NUM2 = BOUNDARY_CLUSTER_NUM1
        BOUNDARY_CLUSTER2(:,:) = BOUNDARY_CLUSTER1(:,:)
        
        END IF
        
        CALL FIND_BOUNDARY_PAIR(TYP, CLUSTER_FLAG1, BOUNDARY_CLUSTER_NUM1, BOUNDARY_CLUSTER1, CLUSTER_FLAG2, BOUNDARY_CLUSTER_NUM2, BOUNDARY_CLUSTER2, BOUNDARY_PAIR_NUM, BOUNDARY_PAIR)
        
        CALL FIND_CORNER_PAIR(TYP, CLUSTER_FLAG1, BOUNDARY_CLUSTER1, CLUSTER_FLAG2, BOUNDARY_CLUSTER2, BOUNDARY_PAIR_NUM, BOUNDARY_PAIR, CORNER_PAIR_NUM, CORNER_PAIR)
        
        DO J=1,CORNER_PAIR_NUM
            CALL CONNECTING_CORNER_CLUSTER(TYP, CORNER_PAIR, J, CORNER_CONNECTION_CLUSTER)
        END DO
        
        DO J=1,BOUNDARY_PAIR_NUM
            B = .FALSE.
            CALL ADDING_REMOVE_FACE(TYP, CLUSTER_FLAG1, BOUNDARY_CLUSTER1, CLUSTER_FLAG2, BOUNDARY_CLUSTER2, BOUNDARY_PAIR, J, CORNER_PAIR_NUM, CORNER_PAIR, CORNER_CONNECTION_CLUSTER, B_REMOVE_FACE, B)
            
            IF(.NOT. B) THEN
            
            CALL FIND_BOUNDARY_TO_ZIPPER(TYP, CLUSTER_FLAG1, BOUNDARY_CLUSTER1, CLUSTER_FLAG2, BOUNDARY_CLUSTER2, BOUNDARY_PAIR, J, CORNER_PAIR_NUM, CORNER_PAIR, CORNER_CONNECTION_CLUSTER, BOUNDARY_ZIPPER_POINT_NUM1, BOUNDARY_ZIPPER_POINT1, BOUNDARY_ZIPPER_POINT_NUM2, BOUNDARY_ZIPPER_POINT2)
            
            CALL ATTACH_BOUNDARY(TYP, BOUNDARY_ZIPPER_POINT_NUM1, BOUNDARY_ZIPPER_POINT1, BOUNDARY_ZIPPER_POINT_NUM2, BOUNDARY_ZIPPER_POINT2)
            
            TEMP = 0
            
            END IF
        END DO
    END DO
    
    CALL TEST_SAVINGDATA_TECPLOT(6000, SURFACE_CURRENT%SURFACE_POINTS_NUM, SURFACE_CURRENT%SURFACE_POINTS, SURFACE_CURRENT%SURFACE_FACES_NUM, SURFACE_CURRENT%SURFACE_FACES)
    
    CALL REMOVE_CERTAIN_FACES(TYP, B_REMOVE_FACE)
    
    CALL TEST_SAVINGDATA_TECPLOT(10000, SURFACE_CURRENT%SURFACE_POINTS_NUM, SURFACE_CURRENT%SURFACE_POINTS, SURFACE_CURRENT%SURFACE_FACES_NUM, SURFACE_CURRENT%SURFACE_FACES)
    
    DEALLOCATE(BOUNDARY_ZIPPER_POINT1, BOUNDARY_ZIPPER_POINT2)
    
    DEALLOCATE(CORNER_CONNECTION_CLUSTER)
    
    DEALLOCATE(CORNER_PAIR)
    
    DEALLOCATE(BOUNDARY_PAIR)
    
    DEALLOCATE(BOUNDARY_CLUSTER1, BOUNDARY_CLUSTER2)
    
    DEALLOCATE(REMOVE_PAIR)
    
    DEALLOCATE(REMOVE_CLUSTER, REMOVE_CLUSTER_INDEX)
    
    DEALLOCATE(B_REMOVE_FACE)
    
    END SUBROUTINE
    
    
    SUBROUTINE FIND_REMOVE_FACES(TYP, THRESHOLD, FLAG, B_REMOVE_FACE)
    IMPLICIT NONE
    INTEGER :: TYP
    REAL(8) :: THRESHOLD
    LOGICAL :: FLAG, B_REMOVE_FACE(:)
    
    LOGICAL, ALLOCATABLE :: REMOVE_REGION(:)
    
    INTEGER :: I, J, K, IPZ, DIR, ITER
    REAL(8) :: R
    LOGICAL :: B, TEMPFLAG
    LOGICAL, ALLOCATABLE :: TEMP_B_REMOVE_FACE(:), BEFORE_B_REMOVE_FACE(:)
    
    INTEGER :: BOUNDARY_NUM, I1
    LOGICAL :: C, D
    
    !REAL(8) :: N(3), N1(3), COST
    
    TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT
    
    IF (TYP==0) THEN
        SURFACE_CURRENT => SURFACE_FLUID
    END IF
    IF (TYP==1) THEN
        SURFACE_CURRENT => SURFACE_PROPEL
    END IF
    IF (TYP==2) THEN
        SURFACE_CURRENT => SURFACE_CASE
    END IF

    FLAG = .FALSE.
    B_REMOVE_FACE(:) = .FALSE.

    TEMPFLAG = .FALSE.
    
    ALLOCATE(REMOVE_REGION(SURFACE_CURRENT%FACE_DIVIDED_REGION_NUM))
    REMOVE_REGION(:) = .FALSE.
    
    B = .TRUE.
    DIR = 0
    !RMIN = 100.
    !IMIN = 1
    DO I=1,SURFACE_CURRENT%SURFACE_FACES_NUM
        IPZ = SURFACE_CURRENT%FACE_IMPACT_ZONE(TYP+1, I)
        IF(IPZ.NE.0) THEN
            CALL DISTANCE_FACE_FACE_TYPE(I,TYP,IPZ,TYP,DIR,  R,B)
            IF(R < THRESHOLD) THEN
                TEMPFLAG = .TRUE.
                REMOVE_REGION(SURFACE_CURRENT%FACE_DIVIDED_REGION_ARRAY(I)) = .TRUE.
            END IF
        END IF
    END DO

    IF(TEMPFLAG) THEN

    ALLOCATE(TEMP_B_REMOVE_FACE(SURFACE_CURRENT%SURFACE_FACES_NUM), BEFORE_B_REMOVE_FACE(SURFACE_CURRENT%SURFACE_FACES_NUM))
    B_REMOVE_FACE(:) = .FALSE.

    DO I=1,SURFACE_CURRENT%SURFACE_FACES_NUM
        IF(REMOVE_REGION(SURFACE_CURRENT%FACE_DIVIDED_REGION_ARRAY(I))) THEN
        
        IPZ = SURFACE_CURRENT%FACE_IMPACT_ZONE(TYP+1, I)
        IF(IPZ.NE.0) THEN
!            CALL TRIANGLE_NORMAL(SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(1,I)), SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(2,I)), SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(3,I)), N)
            
!            CALL TRIANGLE_NORMAL(SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(1,IPZ)), SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(2,IPZ)), SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(3,IPZ)), N1)
            
!            N = N/SQRT(DOT_PRODUCT(N,N))
!            N1 = N1/SQRT(DOT_PRODUCT(N1,N1))
            
!            COST = MAX(-1., MIN(1., DOT_PRODUCT(N,N1) ))
            
!            IF(SQRT(1-COST**2) < 1./10.) THEN
            
            CALL DISTANCE_FACE_FACE_TYPE(I,TYP,IPZ,TYP,DIR,  R,B)
            IF(R < 1.5*THRESHOLD) THEN
                B_REMOVE_FACE(I) = .TRUE.
                
                !IF(REMOVE_REGION(SURFACE_CURRENT%FACE_DIVIDED_REGION_ARRAY(IPZ))) THEN
                !    B_REMOVE_FACE(IPZ) = .TRUE.
                !END IF
            END IF
            
!            END IF
        END IF
        
        END IF
    END DO
    
    DEALLOCATE(REMOVE_REGION)
    
    CALL TEST_SAVINGDATA_TECPLOT(1000, SURFACE_CURRENT%SURFACE_POINTS_NUM, SURFACE_CURRENT%SURFACE_POINTS, SURFACE_CURRENT%SURFACE_FACES_NUM, SURFACE_CURRENT%SURFACE_FACES, SURFACE_CURRENT%FACE_DIVIDED_REGION_ARRAY, SURFACE_CURRENT%FACE_DIVIDED_BOUNDARY_ARRAY, B_REMOVE_FACE)
    
    
    B = .TRUE.
    
    DO WHILE(B)
    
    B = .FALSE.
    
    DO I=1,SURFACE_CURRENT%SURFACE_FACES_NUM
        IF(B_REMOVE_FACE(I)) THEN
            BOUNDARY_NUM = 0
            DO K=1,3
                CALL FACE_NEIGHBOR_FACE(SURFACE_CURRENT%SURFACE_FACES, SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM, SURFACE_CURRENT%POINT_FACE_CONNECTION,I,K, I1)
                IF(.NOT. B_REMOVE_FACE(I1) .AND. SURFACE_CURRENT%FACE_DIVIDED_REGION_ARRAY(I) == SURFACE_CURRENT%FACE_DIVIDED_REGION_ARRAY(I1)) THEN
                    BOUNDARY_NUM = BOUNDARY_NUM + 1
                END IF
            END DO
            IF(BOUNDARY_NUM >= 2) THEN
                B = .TRUE.
                B_REMOVE_FACE(I) = .FALSE.
            END IF
        END IF
    END DO
    
    END DO
    
    CALL TEST_SAVINGDATA_TECPLOT(2000, SURFACE_CURRENT%SURFACE_POINTS_NUM, SURFACE_CURRENT%SURFACE_POINTS, SURFACE_CURRENT%SURFACE_FACES_NUM, SURFACE_CURRENT%SURFACE_FACES, SURFACE_CURRENT%FACE_DIVIDED_REGION_ARRAY, SURFACE_CURRENT%FACE_DIVIDED_BOUNDARY_ARRAY, B_REMOVE_FACE)
    
    B = .TRUE.
    
    DO WHILE(B)
    
    B = .FALSE.
    
    BEFORE_B_REMOVE_FACE(:) = B_REMOVE_FACE(1:SURFACE_CURRENT%SURFACE_FACES_NUM)
    TEMP_B_REMOVE_FACE(:) = B_REMOVE_FACE(1:SURFACE_CURRENT%SURFACE_FACES_NUM)
    
    DO ITER=1,3
    
    DO I=1,SURFACE_CURRENT%SURFACE_POINTS_NUM
        C = .FALSE.
        D = .FALSE.
        DO J=1,SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(I)
            I1 = SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I)
            IF(B_REMOVE_FACE(I1)) THEN
                C = .TRUE.
            ELSE IF(.NOT. B_REMOVE_FACE(I1) .AND. SURFACE_CURRENT%FACE_DIVIDED_REGION_ARRAY(I) == SURFACE_CURRENT%FACE_DIVIDED_REGION_ARRAY(I1)) THEN
                D = .TRUE.
            END IF
        END DO
        
        IF(C .AND. D) THEN
        
        DO J=1,SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(I)
            I1 = SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I)
            IF(.NOT. B_REMOVE_FACE(I1) .AND. SURFACE_CURRENT%FACE_DIVIDED_REGION_ARRAY(I) == SURFACE_CURRENT%FACE_DIVIDED_REGION_ARRAY(I1)) THEN
                TEMP_B_REMOVE_FACE(I1) = .TRUE.
            END IF
        END DO
        
        END IF
    END DO
    
    B_REMOVE_FACE(1:SURFACE_CURRENT%SURFACE_FACES_NUM) = TEMP_B_REMOVE_FACE(:)
    
    END DO
    
    DO ITER=1,3
    
    DO I=1,SURFACE_CURRENT%SURFACE_POINTS_NUM
        C = .FALSE.
        D = .FALSE.
        DO J=1,SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(I)
            I1 = SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I)
            IF(B_REMOVE_FACE(I1) .AND. SURFACE_CURRENT%FACE_DIVIDED_REGION_ARRAY(I) == SURFACE_CURRENT%FACE_DIVIDED_REGION_ARRAY(I1)) THEN
                C = .TRUE.
            ELSE IF(.NOT. B_REMOVE_FACE(I1) .AND. SURFACE_CURRENT%FACE_DIVIDED_REGION_ARRAY(I) == SURFACE_CURRENT%FACE_DIVIDED_REGION_ARRAY(I1)) THEN
                D = .TRUE.
            END IF
        END DO
        
        IF(C .AND. D) THEN
        
        DO J=1,SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(I)
            I1 = SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I)
            IF(B_REMOVE_FACE(I1) .AND. SURFACE_CURRENT%FACE_DIVIDED_REGION_ARRAY(I) == SURFACE_CURRENT%FACE_DIVIDED_REGION_ARRAY(I1)) THEN
                TEMP_B_REMOVE_FACE(I1) = .FALSE.
            END IF
        END DO
        
        END IF
    END DO
    
    B_REMOVE_FACE(1:SURFACE_CURRENT%SURFACE_FACES_NUM) = TEMP_B_REMOVE_FACE(:)
    
    END DO
    
    DO I=1,SURFACE_CURRENT%SURFACE_FACES_NUM
        IF(B_REMOVE_FACE(I) .NE. BEFORE_B_REMOVE_FACE(I)) THEN
            B = .TRUE.
            EXIT
        END IF
    END DO
    
    END DO
    
    CALL TEST_SAVINGDATA_TECPLOT(3000, SURFACE_CURRENT%SURFACE_POINTS_NUM, SURFACE_CURRENT%SURFACE_POINTS, SURFACE_CURRENT%SURFACE_FACES_NUM, SURFACE_CURRENT%SURFACE_FACES, SURFACE_CURRENT%FACE_DIVIDED_REGION_ARRAY, SURFACE_CURRENT%FACE_DIVIDED_BOUNDARY_ARRAY, B_REMOVE_FACE)
    
    B = .TRUE.
    
    DO WHILE(B)
    
    B = .FALSE.
    
    DO I=1,SURFACE_CURRENT%SURFACE_FACES_NUM
        IF(B_REMOVE_FACE(I)) THEN
            BOUNDARY_NUM = 0
            DO K=1,3
                CALL FACE_NEIGHBOR_FACE(SURFACE_CURRENT%SURFACE_FACES, SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM, SURFACE_CURRENT%POINT_FACE_CONNECTION,I,K, I1)
                IF(.NOT. B_REMOVE_FACE(I1) .AND. SURFACE_CURRENT%FACE_DIVIDED_REGION_ARRAY(I) == SURFACE_CURRENT%FACE_DIVIDED_REGION_ARRAY(I1)) THEN
                    BOUNDARY_NUM = BOUNDARY_NUM + 1
                END IF
            END DO
            IF(BOUNDARY_NUM >= 2) THEN
                B = .TRUE.
                B_REMOVE_FACE(I) = .FALSE.
            END IF
        END IF
    END DO
    
    END DO
    
    CALL TEST_SAVINGDATA_TECPLOT(4000, SURFACE_CURRENT%SURFACE_POINTS_NUM, SURFACE_CURRENT%SURFACE_POINTS, SURFACE_CURRENT%SURFACE_FACES_NUM, SURFACE_CURRENT%SURFACE_FACES, SURFACE_CURRENT%FACE_DIVIDED_REGION_ARRAY, SURFACE_CURRENT%FACE_DIVIDED_BOUNDARY_ARRAY, B_REMOVE_FACE)
    
!    IF(TYP==1) THEN
!        DO I=1,SURFACE_CURRENT%SURFACE_FACES_NUM/2
!            IF(.NOT. B_REMOVE_FACE(2*I-1) .OR. .NOT. B_REMOVE_FACE(2*I)) THEN
!                B_REMOVE_FACE(2*I-1) = .FALSE.
!                B_REMOVE_FACE(2*I) = .FALSE.
!            END IF
!        END DO
!    END IF
    
    CALL TEST_SAVINGDATA_TECPLOT(5000, SURFACE_CURRENT%SURFACE_POINTS_NUM, SURFACE_CURRENT%SURFACE_POINTS, SURFACE_CURRENT%SURFACE_FACES_NUM, SURFACE_CURRENT%SURFACE_FACES, SURFACE_CURRENT%FACE_DIVIDED_REGION_ARRAY, SURFACE_CURRENT%FACE_DIVIDED_BOUNDARY_ARRAY, B_REMOVE_FACE)
    
    DEALLOCATE(TEMP_B_REMOVE_FACE, BEFORE_B_REMOVE_FACE)
    
    END IF

    !DEALLOCATE(PATCH_PARENT)

    END SUBROUTINE
    
    
    SUBROUTINE FIND_REMOVE_CLUSTERS(TYP, B_REMOVE_FACE, REMOVE_CLUSTER_NUM, REMOVE_CLUSTER, REMOVE_CLUSTER_INDEX)
    IMPLICIT NONE
    INTEGER :: TYP
    LOGICAL :: B_REMOVE_FACE(:)
    INTEGER :: REMOVE_CLUSTER_NUM
    INTEGER :: REMOVE_CLUSTER(:,:)
    INTEGER :: REMOVE_CLUSTER_INDEX(:)
    
    INTEGER :: CURRENT_CLUSTER_NUM, TEMP_CLUSTER_NUM
    
    LOGICAL, ALLOCATABLE :: USED_FACE(:)
    
    INTEGER :: I, K, I0, I1
    LOGICAL :: B, C
    
    TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT
    
    IF (TYP==0) THEN
        SURFACE_CURRENT => SURFACE_FLUID
    END IF
    IF (TYP==1) THEN
        SURFACE_CURRENT => SURFACE_PROPEL
    END IF
    IF (TYP==2) THEN
        SURFACE_CURRENT => SURFACE_CASE
    END IF
    
    REMOVE_CLUSTER_NUM = 0
    REMOVE_CLUSTER(:,:) = 0
    REMOVE_CLUSTER_INDEX(:) = 0
    
    ALLOCATE(USED_FACE(SURFACE_CURRENT%SURFACE_FACES_NUM))
    USED_FACE(:) = .NOT. B_REMOVE_FACE(1:SURFACE_CURRENT%SURFACE_FACES_NUM)
    
    C = .TRUE.
    DO WHILE(C)
        C = .FALSE.
        DO I=1,SURFACE_CURRENT%SURFACE_FACES_NUM
            IF(.NOT. USED_FACE(I)) THEN
                C = .TRUE.
                EXIT
            END IF
        END DO
        
        IF(C) THEN
        
        REMOVE_CLUSTER_NUM = REMOVE_CLUSTER_NUM + 1
        REMOVE_CLUSTER(1,REMOVE_CLUSTER_NUM) = I
        REMOVE_CLUSTER_INDEX(I) = REMOVE_CLUSTER_NUM
        USED_FACE(I) = .TRUE.
        CURRENT_CLUSTER_NUM = 1
        TEMP_CLUSTER_NUM = 1
        
        B = .TRUE.
        DO WHILE(B)
            B = .FALSE.
            
            DO I = 1,CURRENT_CLUSTER_NUM
                I0 = REMOVE_CLUSTER(I,REMOVE_CLUSTER_NUM)
                
                DO K=1,3
                    CALL FACE_NEIGHBOR_FACE(SURFACE_CURRENT%SURFACE_FACES, SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM, SURFACE_CURRENT%POINT_FACE_CONNECTION,I0,K, I1)
                    
                    IF(.NOT. USED_FACE(I1)) THEN
                        B = .TRUE.
                        TEMP_CLUSTER_NUM = TEMP_CLUSTER_NUM + 1
                        REMOVE_CLUSTER(TEMP_CLUSTER_NUM, REMOVE_CLUSTER_NUM) = I1
                        REMOVE_CLUSTER_INDEX(I1) = REMOVE_CLUSTER_NUM
                        USED_FACE(I1) = .TRUE.
                    END IF
                END DO
            END DO
            
            CURRENT_CLUSTER_NUM = TEMP_CLUSTER_NUM
            
        END DO
        
        IF(CURRENT_CLUSTER_NUM < 10) THEN
            REMOVE_CLUSTER(1:CURRENT_CLUSTER_NUM, REMOVE_CLUSTER_NUM) = 0
            
            DO I=1,SURFACE_CURRENT%SURFACE_FACES_NUM
                IF(REMOVE_CLUSTER_INDEX(I)==REMOVE_CLUSTER_NUM) REMOVE_CLUSTER_INDEX(I) = 0
            END DO
            
            REMOVE_CLUSTER_NUM = REMOVE_CLUSTER_NUM - 1
        END IF
        
        END IF
    END DO
    
    DEALLOCATE(USED_FACE)
    
    END SUBROUTINE
    
    
    SUBROUTINE FIND_REMOVE_PAIRS(TYP, REMOVE_CLUSTER_NUM, REMOVE_CLUSTER, REMOVE_CLUSTER_INDEX, REMOVE_PAIR_NUM, REMOVE_PAIR)
    IMPLICIT NONE
    INTEGER :: TYP
    INTEGER :: REMOVE_CLUSTER_NUM
    INTEGER :: REMOVE_CLUSTER(:,:)
    INTEGER :: REMOVE_CLUSTER_INDEX(:)
    INTEGER :: REMOVE_PAIR_NUM
    INTEGER :: REMOVE_PAIR(:,:)
    
    INTEGER :: I, ITER, IPZ, I1
    LOGICAL :: B
    
    TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT
    
    IF (TYP==0) THEN
        SURFACE_CURRENT => SURFACE_FLUID
    END IF
    IF (TYP==1) THEN
        SURFACE_CURRENT => SURFACE_PROPEL
    END IF
    IF (TYP==2) THEN
        SURFACE_CURRENT => SURFACE_CASE
    END IF
    
    REMOVE_PAIR_NUM = 0
    REMOVE_PAIR(:,:) = 0
    
    DO ITER=1,REMOVE_CLUSTER_NUM
        
        B = .TRUE.
        
        DO I = 1,REMOVE_PAIR_NUM
            IF(REMOVE_PAIR(1,I)==ITER .OR. REMOVE_PAIR(2,I)==ITER) THEN
                B = .FALSE.
                EXIT
            END IF
        END DO
        
        IF(B) THEN
        
        I = 1
        DO WHILE(REMOVE_CLUSTER(I,ITER) .NE. 0)
            I1 = REMOVE_CLUSTER(I,ITER)
            IPZ = SURFACE_CURRENT%FACE_IMPACT_ZONE(TYP+1, I1)
            
            IF(IPZ .NE. 0) THEN
            IF(REMOVE_CLUSTER_INDEX(IPZ) .NE. 0) THEN
                REMOVE_PAIR_NUM = REMOVE_PAIR_NUM + 1
                REMOVE_PAIR(1,REMOVE_PAIR_NUM) = ITER
                REMOVE_PAIR(2,REMOVE_PAIR_NUM) = REMOVE_CLUSTER_INDEX(IPZ)
                EXIT
            END IF
            END IF
            
            I = I + 1
        END DO
        
        END IF
    END DO
    
    END SUBROUTINE
    
    SUBROUTINE FIND_BOUNDARY_CLUSTER(TYP, REMOVE_CLUSTER_INDEX, CLUSTER_FLAG, BOUNDARY_CLUSTER_NUM, BOUNDARY_CLUSTER)
    IMPLICIT NONE
    INTEGER :: TYP
    INTEGER :: REMOVE_CLUSTER_INDEX(:)
    INTEGER :: CLUSTER_FLAG
    
    INTEGER :: BOUNDARY_CLUSTER_NUM
    INTEGER :: BOUNDARY_CLUSTER(:,:)
    
    INTEGER :: BOUNDARY_NUM
    INTEGER, ALLOCATABLE :: BOUNDARY(:,:)
    
    INTEGER, ALLOCATABLE :: BOUNDARY_INDEX(:,:)
    
    LOGICAL, ALLOCATABLE :: USED_BOUNDARY(:)
    
    INTEGER :: CURRENT_CLUSTER_NUM
    INTEGER :: I,K,L,T,I0,K0,I1,J1, ITER
    LOGICAL :: B,C
    
    TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT
    
    IF (TYP==0) THEN
        SURFACE_CURRENT => SURFACE_FLUID
    END IF
    IF (TYP==1) THEN
        SURFACE_CURRENT => SURFACE_PROPEL
    END IF
    IF (TYP==2) THEN
        SURFACE_CURRENT => SURFACE_CASE
    END IF
    
    ALLOCATE(BOUNDARY(2, SURFACE_CURRENT%SURFACE_FACES_NUM), BOUNDARY_INDEX(3,SURFACE_CURRENT%SURFACE_FACES_NUM))
    BOUNDARY_NUM = 0
    BOUNDARY(:,:) = 0
    BOUNDARY_INDEX(:,:) = 0
    
    DO I=1,SURFACE_CURRENT%SURFACE_FACES_NUM
        
        IF(REMOVE_CLUSTER_INDEX(I)==CLUSTER_FLAG) THEN
        
        DO K=1,3
            CALL FACE_NEIGHBOR_FACE(SURFACE_CURRENT%SURFACE_FACES, SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM, SURFACE_CURRENT%POINT_FACE_CONNECTION,I,K, I1)
            
            IF(REMOVE_CLUSTER_INDEX(I1) .NE. CLUSTER_FLAG) THEN
                BOUNDARY_NUM = BOUNDARY_NUM + 1
                BOUNDARY(1,BOUNDARY_NUM) = I
                BOUNDARY(2,BOUNDARY_NUM) = K
                
                BOUNDARY_INDEX(K,I) = BOUNDARY_NUM
                
                DO L=1,3
                    IF(SURFACE_CURRENT%SURFACE_FACES(K,I) == SURFACE_CURRENT%SURFACE_FACES(MOD(L,3)+1,I1)) THEN
                        EXIT
                    END IF
                END DO
                
                BOUNDARY_INDEX(L,I1) = BOUNDARY_NUM
            END IF
        END DO
        
        END IF
    END DO
    
    ALLOCATE(USED_BOUNDARY(BOUNDARY_NUM))
    USED_BOUNDARY(:) = .FALSE.
    BOUNDARY_CLUSTER_NUM = 0
    BOUNDARY_CLUSTER(:,:) = 0
    
    C = .TRUE.
    DO WHILE(C)
        C = .FALSE.
        DO ITER=1,BOUNDARY_NUM
            IF(.NOT. USED_BOUNDARY(ITER)) THEN
                C = .TRUE.
                EXIT
            END IF
        END DO
        
        IF(C) THEN
        
        BOUNDARY_CLUSTER_NUM = BOUNDARY_CLUSTER_NUM + 1
        BOUNDARY_CLUSTER(SURFACE_CURRENT%SURFACE_FACES_NUM,BOUNDARY_CLUSTER_NUM) = ITER
        USED_BOUNDARY(ITER) = .TRUE.
        CURRENT_CLUSTER_NUM = 1
        
        B = .TRUE.
        DO WHILE(B)
            B = .FALSE.
            
            ITER = BOUNDARY_CLUSTER(SURFACE_CURRENT%SURFACE_FACES_NUM+1 - CURRENT_CLUSTER_NUM, BOUNDARY_CLUSTER_NUM)
            I0 = BOUNDARY(1,ITER)
            K0 = BOUNDARY(2,ITER)
            
            J1 = SURFACE_CURRENT%SURFACE_FACES(K0,I0)
            
            DO T=1,SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(J1)
                I1 = SURFACE_CURRENT%POINT_FACE_CONNECTION(T,J1)
                
                DO L=1,3
                    IF(J1 == SURFACE_CURRENT%SURFACE_FACES(L,I1)) THEN
                        EXIT
                    END IF
                END DO
                
                IF(BOUNDARY_INDEX(L,I1) .NE. ITER .AND. BOUNDARY_INDEX(L,I1) .NE. 0) THEN
                    EXIT
                END IF
            END DO
            
            IF(.NOT. USED_BOUNDARY(BOUNDARY_INDEX(L,I1)) .AND. SURFACE_CURRENT%FACE_DIVIDED_BOUNDARY_ARRAY(L,I1) == SURFACE_CURRENT%FACE_DIVIDED_BOUNDARY_ARRAY(K0,I0)) THEN
                B = .TRUE.
                CURRENT_CLUSTER_NUM = CURRENT_CLUSTER_NUM + 1
                BOUNDARY_CLUSTER(SURFACE_CURRENT%SURFACE_FACES_NUM+1 - CURRENT_CLUSTER_NUM, BOUNDARY_CLUSTER_NUM) = BOUNDARY_INDEX(L,I1)
                
                USED_BOUNDARY(BOUNDARY_INDEX(L,I1)) = .TRUE.
            END IF
            
        END DO
        
        DO I=1,CURRENT_CLUSTER_NUM
            BOUNDARY_CLUSTER(I,BOUNDARY_CLUSTER_NUM) = BOUNDARY_CLUSTER(SURFACE_CURRENT%SURFACE_FACES_NUM - CURRENT_CLUSTER_NUM + I,BOUNDARY_CLUSTER_NUM)
        END DO
        
        B = .TRUE.
        DO WHILE(B)
            B = .FALSE.
            
            ITER = BOUNDARY_CLUSTER(CURRENT_CLUSTER_NUM, BOUNDARY_CLUSTER_NUM)
            I0 = BOUNDARY(1,ITER)
            K0 = BOUNDARY(2,ITER)
            
            J1 = SURFACE_CURRENT%SURFACE_FACES(MOD(K0,3)+1,I0)
            
            DO T=1,SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(J1)
                I1 = SURFACE_CURRENT%POINT_FACE_CONNECTION(T,J1)
                
                DO L=1,3
                    IF(J1 == SURFACE_CURRENT%SURFACE_FACES(L,I1)) THEN
                        EXIT
                    END IF
                END DO
                
                IF(BOUNDARY_INDEX(L,I1) .NE. ITER .AND. BOUNDARY_INDEX(L,I1) .NE. 0) THEN
                    EXIT
                END IF
            END DO
            
            IF(.NOT. USED_BOUNDARY(BOUNDARY_INDEX(L,I1)) .AND. SURFACE_CURRENT%FACE_DIVIDED_BOUNDARY_ARRAY(L,I1) == SURFACE_CURRENT%FACE_DIVIDED_BOUNDARY_ARRAY(K0,I0)) THEN
                B = .TRUE.
                CURRENT_CLUSTER_NUM = CURRENT_CLUSTER_NUM + 1
                BOUNDARY_CLUSTER(CURRENT_CLUSTER_NUM, BOUNDARY_CLUSTER_NUM) = BOUNDARY_INDEX(L,I1)
                
                USED_BOUNDARY(BOUNDARY_INDEX(L,I1)) = .TRUE.
            END IF
            
        END DO
        
        END IF
    END DO
    
    
    DO ITER = 1,BOUNDARY_CLUSTER_NUM
        I = 1
        DO WHILE(BOUNDARY_CLUSTER(I,ITER) .NE. 0)
            BOUNDARY_CLUSTER(I,ITER) = BOUNDARY(1,BOUNDARY_CLUSTER(I,ITER)) * 3 + BOUNDARY(2,BOUNDARY_CLUSTER(I,ITER)) - 1
            I = I+1
        END DO
    END DO
    
    
    DEALLOCATE(USED_BOUNDARY)
    
    DEALLOCATE(BOUNDARY, BOUNDARY_INDEX)
    
    END SUBROUTINE
    
    
    SUBROUTINE FIND_BOUNDARY_PAIR(TYP, CLUSTER_FLAG1, BOUNDARY_CLUSTER_NUM1, BOUNDARY_CLUSTER1, CLUSTER_FLAG2, BOUNDARY_CLUSTER_NUM2, BOUNDARY_CLUSTER2, BOUNDARY_PAIR_NUM, BOUNDARY_PAIR)
    IMPLICIT NONE
    INTEGER :: TYP
    
    INTEGER :: CLUSTER_FLAG1
    INTEGER :: BOUNDARY_CLUSTER_NUM1
    INTEGER :: BOUNDARY_CLUSTER1(:,:)
    
    INTEGER :: CLUSTER_FLAG2
    INTEGER :: BOUNDARY_CLUSTER_NUM2
    INTEGER :: BOUNDARY_CLUSTER2(:,:)
    
    INTEGER :: BOUNDARY_PAIR_NUM
    INTEGER :: BOUNDARY_PAIR(:,:)
    
    INTEGER, ALLOCATABLE :: TEMP_PAIR1(:), TEMP_PAIR2(:)
    LOGICAL, ALLOCATABLE :: USED_CLUSTER(:)
    INTEGER, ALLOCATABLE :: BOUNDARY_CLUSTER_INDEX(:,:)
    
    INTEGER :: I,L,I0,K0,I1, ITER
    LOGICAL :: B, C
    
    TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT
    
    IF (TYP==0) THEN
        SURFACE_CURRENT => SURFACE_FLUID
    END IF
    IF (TYP==1) THEN
        SURFACE_CURRENT => SURFACE_PROPEL
    END IF
    IF (TYP==2) THEN
        SURFACE_CURRENT => SURFACE_CASE
    END IF
    
    
    ALLOCATE(BOUNDARY_CLUSTER_INDEX(3,SURFACE_CURRENT%SURFACE_FACES_NUM))
    
    DO ITER=1,BOUNDARY_CLUSTER_NUM2
        I = 1
        DO WHILE(BOUNDARY_CLUSTER2(I,ITER) .NE. 0)
            K0 = MOD(BOUNDARY_CLUSTER2(I,ITER),3)+1
            I0 = (BOUNDARY_CLUSTER2(I,ITER) - MOD(BOUNDARY_CLUSTER2(I,ITER),3))/3
!            I0 = BOUNDARY2(1,BOUNDARY_CLUSTER2(I,ITER))
!            K0 = BOUNDARY2(2,BOUNDARY_CLUSTER2(I,ITER))
            
            BOUNDARY_CLUSTER_INDEX(K0,I0) = ITER
            
            CALL FACE_NEIGHBOR_FACE(SURFACE_CURRENT%SURFACE_FACES, SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM, SURFACE_CURRENT%POINT_FACE_CONNECTION,I0,K0, I1)
            DO L=1,3
                IF(SURFACE_CURRENT%SURFACE_FACES(K0,I0) == SURFACE_CURRENT%SURFACE_FACES(MOD(L,3)+1,I1)) THEN
                    EXIT
                END IF
            END DO
            
            BOUNDARY_CLUSTER_INDEX(L,I1) = ITER
            
            I = I+1
        END DO
    END DO
    
    ALLOCATE(TEMP_PAIR1(2*BOUNDARY_CLUSTER_NUM1), TEMP_PAIR2(2*BOUNDARY_CLUSTER_NUM2), USED_CLUSTER(BOUNDARY_CLUSTER_NUM1))
    TEMP_PAIR1(:) = 0
    TEMP_PAIR2(:) = 0
    USED_CLUSTER(:) = .FALSE.
    
    BOUNDARY_PAIR_NUM = 0
    BOUNDARY_PAIR(:,:) = 0
    
    DO ITER=1,BOUNDARY_CLUSTER_NUM1
        CALL MATCHING_SIMILAR_BOUNDARY_CLUSTER(TYP, BOUNDARY_CLUSTER1(:,ITER), BOUNDARY_CLUSTER_NUM2, BOUNDARY_CLUSTER2, TEMP_PAIR1(ITER))
    END DO
    
    IF(CLUSTER_FLAG1 .NE. CLUSTER_FLAG2) THEN
    
    DO ITER=1,BOUNDARY_CLUSTER_NUM2
        CALL MATCHING_SIMILAR_BOUNDARY_CLUSTER(TYP, BOUNDARY_CLUSTER2(:,ITER), BOUNDARY_CLUSTER_NUM1, BOUNDARY_CLUSTER1, TEMP_PAIR2(ITER))
    END DO
    
    ELSE
    
    TEMP_PAIR2(:) = TEMP_PAIR1(:)
    
    END IF
    
    B = .TRUE.
    DO WHILE(B)
        B = .FALSE.
        
        IF(CLUSTER_FLAG1 .NE. CLUSTER_FLAG2) THEN
        
        C = .FALSE.
        DO ITER=1,BOUNDARY_CLUSTER_NUM2
            CALL DIVIDE_BOUNDARY_CLUSTER(TYP, CLUSTER_FLAG2, BOUNDARY_CLUSTER_NUM2, BOUNDARY_CLUSTER2, TEMP_PAIR2, ITER, CLUSTER_FLAG1, BOUNDARY_CLUSTER_NUM1, BOUNDARY_CLUSTER1, TEMP_PAIR1, C)
        END DO
        IF(C) THEN
            B = .TRUE.
            
            DO ITER=1,BOUNDARY_CLUSTER_NUM1
                CALL MATCHING_SIMILAR_BOUNDARY_CLUSTER(TYP, BOUNDARY_CLUSTER1(:,ITER), BOUNDARY_CLUSTER_NUM2, BOUNDARY_CLUSTER2, TEMP_PAIR1(ITER))
            END DO
            
            DO ITER=1,BOUNDARY_CLUSTER_NUM2
                CALL MATCHING_SIMILAR_BOUNDARY_CLUSTER(TYP, BOUNDARY_CLUSTER2(:,ITER), BOUNDARY_CLUSTER_NUM1, BOUNDARY_CLUSTER1, TEMP_PAIR2(ITER))
            END DO
        END IF
        
        C = .FALSE.
        DO ITER=1,BOUNDARY_CLUSTER_NUM1
            CALL DIVIDE_BOUNDARY_CLUSTER(TYP, CLUSTER_FLAG1, BOUNDARY_CLUSTER_NUM1, BOUNDARY_CLUSTER1, TEMP_PAIR1, ITER, CLUSTER_FLAG2, BOUNDARY_CLUSTER_NUM2, BOUNDARY_CLUSTER2, TEMP_PAIR2, C)
        END DO
        IF(C) THEN
            B = .TRUE.
            
            DO ITER=1,BOUNDARY_CLUSTER_NUM1
                CALL MATCHING_SIMILAR_BOUNDARY_CLUSTER(TYP, BOUNDARY_CLUSTER1(:,ITER), BOUNDARY_CLUSTER_NUM2, BOUNDARY_CLUSTER2, TEMP_PAIR1(ITER))
            END DO
            
            DO ITER=1,BOUNDARY_CLUSTER_NUM2
                CALL MATCHING_SIMILAR_BOUNDARY_CLUSTER(TYP, BOUNDARY_CLUSTER2(:,ITER), BOUNDARY_CLUSTER_NUM1, BOUNDARY_CLUSTER1, TEMP_PAIR2(ITER))
            END DO
        END IF
        
        ELSE
        
        C = .FALSE.
        DO ITER=1,BOUNDARY_CLUSTER_NUM2
            CALL DIVIDE_BOUNDARY_CLUSTER(TYP, CLUSTER_FLAG2, BOUNDARY_CLUSTER_NUM2, BOUNDARY_CLUSTER2, TEMP_PAIR2, ITER, CLUSTER_FLAG1, BOUNDARY_CLUSTER_NUM1, BOUNDARY_CLUSTER1, TEMP_PAIR1, C)
        END DO
        IF(C) THEN
            B = .TRUE.
            
            BOUNDARY_CLUSTER_NUM1 = BOUNDARY_CLUSTER_NUM2
            BOUNDARY_CLUSTER1(:,:) = BOUNDARY_CLUSTER2(:,:)
            
            DO ITER=1,BOUNDARY_CLUSTER_NUM1
                CALL MATCHING_SIMILAR_BOUNDARY_CLUSTER(TYP, BOUNDARY_CLUSTER1(:,ITER), BOUNDARY_CLUSTER_NUM2, BOUNDARY_CLUSTER2, TEMP_PAIR1(ITER))
            END DO
            TEMP_PAIR2(:) = TEMP_PAIR1(:)
        END IF
        
        END IF
    END DO
    
    IF(CLUSTER_FLAG1 .NE. CLUSTER_FLAG2) THEN
        BOUNDARY_PAIR_NUM = BOUNDARY_CLUSTER_NUM1
        DO ITER=1,BOUNDARY_CLUSTER_NUM1
            BOUNDARY_PAIR(1,ITER) = ITER
            BOUNDARY_PAIR(2,ITER) = TEMP_PAIR1(ITER)
        END DO
    ELSE
        BOUNDARY_PAIR_NUM = 0
        DO ITER=1,BOUNDARY_CLUSTER_NUM1
            B = .TRUE.
            DO I=1,BOUNDARY_PAIR_NUM
                IF(BOUNDARY_PAIR(1,I)==ITER .OR. BOUNDARY_PAIR(2,I)==ITER) THEN
                    B = .FALSE.
                    EXIT
                END IF
            END DO
            
            IF(B) THEN
                BOUNDARY_PAIR_NUM = BOUNDARY_PAIR_NUM + 1
                BOUNDARY_PAIR(1,BOUNDARY_PAIR_NUM) = ITER
                BOUNDARY_PAIR(2,BOUNDARY_PAIR_NUM) = TEMP_PAIR1(ITER)
            END IF
        END DO
    END IF
    
    DEALLOCATE(TEMP_PAIR1, TEMP_PAIR2, USED_CLUSTER)
    
    DEALLOCATE(BOUNDARY_CLUSTER_INDEX)
    
    END SUBROUTINE
    
    
    SUBROUTINE DIVIDE_BOUNDARY_CLUSTER(TYP, CLUSTER_FLAG1, BOUNDARY_CLUSTER_NUM1, BOUNDARY_CLUSTER1, TEMP_PAIR1, BOUNDARY_CLUSTER_FLAG, CLUSTER_FLAG2, BOUNDARY_CLUSTER_NUM2, BOUNDARY_CLUSTER2, TEMP_PAIR2, FLAG)
    IMPLICIT NONE
    INTEGER :: TYP
    INTEGER :: CLUSTER_FLAG1
    INTEGER :: BOUNDARY_CLUSTER_NUM1
    INTEGER :: BOUNDARY_CLUSTER1(:,:)
    INTEGER :: TEMP_PAIR1(:)
    INTEGER :: BOUNDARY_CLUSTER_FLAG
    
    INTEGER :: CLUSTER_FLAG2
    INTEGER :: BOUNDARY_CLUSTER_NUM2
    INTEGER :: BOUNDARY_CLUSTER2(:,:)
    INTEGER :: TEMP_PAIR2(:)
    
    LOGICAL :: FLAG
    
    INTEGER :: I, I0, K0, ITER, NUM, ITER_MIN, IMIN
    REAL(8) :: R, RMIN, FIRST_POINT1(3), LAST_POINT1(3), FIRST_POINT2(3), LAST_POINT2(3)
    
    TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT
    
    IF (TYP==0) THEN
        SURFACE_CURRENT => SURFACE_FLUID
    END IF
    IF (TYP==1) THEN
        SURFACE_CURRENT => SURFACE_PROPEL
    END IF
    IF (TYP==2) THEN
        SURFACE_CURRENT => SURFACE_CASE
    END IF
    
    K0 = MOD(BOUNDARY_CLUSTER1(1,BOUNDARY_CLUSTER_FLAG),3)+1
    I0 = (BOUNDARY_CLUSTER1(1,BOUNDARY_CLUSTER_FLAG) - MOD(BOUNDARY_CLUSTER1(1,BOUNDARY_CLUSTER_FLAG),3))/3
    
    FIRST_POINT1(:) = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(K0,I0))
    
    RMIN = MAX(DOMAIN_MAX(1) - DOMAIN_MIN(1), DOMAIN_MAX(2) - DOMAIN_MIN(2), DOMAIN_MAX(3) - DOMAIN_MIN(3))
    ITER_MIN = 0
    NUM = 0
    DO ITER = 1,BOUNDARY_CLUSTER_NUM2
        
        IF(TEMP_PAIR2(ITER) == BOUNDARY_CLUSTER_FLAG) THEN
            NUM = NUM + 1
            
            I=1
            DO WHILE(BOUNDARY_CLUSTER2(I+1,ITER) .NE. 0)
                I = I+1
            END DO
            K0 = MOD(BOUNDARY_CLUSTER2(I,ITER),3)+1
            I0 = (BOUNDARY_CLUSTER2(I,ITER) - MOD(BOUNDARY_CLUSTER2(I,ITER),3))/3
            LAST_POINT2(:) = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(K0,I0))
            
            R = SQRT(DOT_PRODUCT(FIRST_POINT1 - LAST_POINT2, FIRST_POINT1 - LAST_POINT2))
            
            IF(R < RMIN) THEN
                RMIN = R
                ITER_MIN = ITER
            END IF
            
        END IF
    END DO
    
    IF(NUM > 1) THEN
        K0 = MOD(BOUNDARY_CLUSTER2(I,ITER_MIN),3)+1
        I0 = (BOUNDARY_CLUSTER2(I,ITER_MIN) - MOD(BOUNDARY_CLUSTER2(I,ITER_MIN),3))/3
        FIRST_POINT2(:) = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(K0,I0))
        
        RMIN = MAX(DOMAIN_MAX(1) - DOMAIN_MIN(1), DOMAIN_MAX(2) - DOMAIN_MIN(2), DOMAIN_MAX(3) - DOMAIN_MIN(3))
        IMIN = 0
        
        I = 1
        DO WHILE(BOUNDARY_CLUSTER1(I,BOUNDARY_CLUSTER_FLAG) .NE. 0)
            K0 = MOD(BOUNDARY_CLUSTER1(I,BOUNDARY_CLUSTER_FLAG),3)+1
            I0 = (BOUNDARY_CLUSTER1(I,BOUNDARY_CLUSTER_FLAG) - MOD(BOUNDARY_CLUSTER1(I,BOUNDARY_CLUSTER_FLAG),3))/3
            LAST_POINT1(:) = SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(K0,I0))
            
            R = SQRT(DOT_PRODUCT(FIRST_POINT2 - LAST_POINT1, FIRST_POINT2 - LAST_POINT1))
            
            IF(R < RMIN) THEN
                RMIN = R
                IMIN = I
            END IF
            
            I = I+1
        END DO
        
        BOUNDARY_CLUSTER_NUM1 = BOUNDARY_CLUSTER_NUM1 + 1
        
        I = IMIN + 1
        DO WHILE(BOUNDARY_CLUSTER1(I,BOUNDARY_CLUSTER_FLAG) .NE. 0)
            BOUNDARY_CLUSTER1(I-IMIN,BOUNDARY_CLUSTER_NUM1) = BOUNDARY_CLUSTER1(I,BOUNDARY_CLUSTER_FLAG)
            BOUNDARY_CLUSTER1(I,BOUNDARY_CLUSTER_FLAG) = 0
            I = I+1
        END DO
        
        FLAG = .TRUE.
    END IF
    END SUBROUTINE
    
    SUBROUTINE MATCHING_SIMILAR_BOUNDARY_CLUSTER(TYP, ONE_BOUNDARY_CLUSTER, BOUNDARY_CLUSTER_NUM, BOUNDARY_CLUSTER, SIMILAR_BOUNDARY)
    IMPLICIT NONE
    INTEGER :: TYP
    
    INTEGER :: ONE_BOUNDARY_CLUSTER(:)
    
    INTEGER :: BOUNDARY_CLUSTER_NUM
    INTEGER :: BOUNDARY_CLUSTER(:,:)
    
    INTEGER :: SIMILAR_BOUNDARY
    
    INTEGER :: TEMP_BOUNDARY_CLUSTER_NUM
    REAL(8), ALLOCATABLE :: TEMP_BOUNDARY_CLUSTER(:,:)
    
    REAL(8) :: V(3), R, RMIN, R_AVG, R_AVG_MIN
    
    INTEGER :: I,J,I0,K0,IPZ, ITER
    
    TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT
    
    IF (TYP==0) THEN
        SURFACE_CURRENT => SURFACE_FLUID
    END IF
    IF (TYP==1) THEN
        SURFACE_CURRENT => SURFACE_PROPEL
    END IF
    IF (TYP==2) THEN
        SURFACE_CURRENT => SURFACE_CASE
    END IF
    
    ALLOCATE(TEMP_BOUNDARY_CLUSTER(3,SURFACE_CURRENT%SURFACE_FACES_NUM))
    
    I = 1
    TEMP_BOUNDARY_CLUSTER_NUM = 0
    DO WHILE(ONE_BOUNDARY_CLUSTER(I) .NE. 0)
        K0 = MOD(ONE_BOUNDARY_CLUSTER(I),3)+1
        I0 = (ONE_BOUNDARY_CLUSTER(I) - MOD(ONE_BOUNDARY_CLUSTER(I),3))/3
        
        IPZ = SURFACE_CURRENT%FACE_IMPACT_ZONE(TYP+1, I0)
        
        IF(IPZ .NE. 0) THEN
        
        V = ( SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(K0,I0)) + SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(MOD(K0,3)+1,I0)) )/2.
        
        CALL PROJECTION_FACE_POINT(V,SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(1,IPZ)),SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(2,IPZ)),SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(3,IPZ)))
        
        TEMP_BOUNDARY_CLUSTER_NUM = TEMP_BOUNDARY_CLUSTER_NUM + 1
        TEMP_BOUNDARY_CLUSTER(:,TEMP_BOUNDARY_CLUSTER_NUM) = V
        
        END IF
        
        I = I + 1
    END DO
    
    R_AVG_MIN = MAX(DOMAIN_MAX(1) - DOMAIN_MIN(1), DOMAIN_MAX(2) - DOMAIN_MIN(2), DOMAIN_MAX(3) - DOMAIN_MIN(3))
    SIMILAR_BOUNDARY = 0
    
    DO ITER=1,BOUNDARY_CLUSTER_NUM
        R_AVG = 0.
        
        DO J=1,TEMP_BOUNDARY_CLUSTER_NUM
            RMIN = MAX(DOMAIN_MAX(1) - DOMAIN_MIN(1), DOMAIN_MAX(2) - DOMAIN_MIN(2), DOMAIN_MAX(3) - DOMAIN_MIN(3))
            
            I = 1
            DO WHILE(BOUNDARY_CLUSTER(I,ITER) .NE. 0)
                K0 = MOD(BOUNDARY_CLUSTER(I,ITER),3)+1
                I0 = (BOUNDARY_CLUSTER(I,ITER) - MOD(BOUNDARY_CLUSTER(I,ITER),3))/3
                
                CALL UNSIGNED_DISTANCE_EDGE_POINT(TEMP_BOUNDARY_CLUSTER(:,J),SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(K0,I0)),SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(MOD(K0,3)+1,I0)),R)
                
                IF(R < RMIN) THEN
                    RMIN = R
                END IF
                
                I = I + 1
            END DO
            
            R_AVG = R_AVG + RMIN
        END DO
        
        R_AVG = R_AVG / REAL(TEMP_BOUNDARY_CLUSTER_NUM)
        
        IF(R_AVG < R_AVG_MIN) THEN
            R_AVG_MIN = R_AVG
            SIMILAR_BOUNDARY = ITER
        END IF
    END DO
    
    DEALLOCATE(TEMP_BOUNDARY_CLUSTER)
    
    END SUBROUTINE MATCHING_SIMILAR_BOUNDARY_CLUSTER
    
    
    SUBROUTINE FIND_CORNER_PAIR(TYP, CLUSTER_FLAG1, BOUNDARY_CLUSTER1, CLUSTER_FLAG2, BOUNDARY_CLUSTER2, BOUNDARY_PAIR_NUM, BOUNDARY_PAIR, CORNER_PAIR_NUM, CORNER_PAIR)
    IMPLICIT NONE
    INTEGER :: TYP
    
    INTEGER :: CLUSTER_FLAG1
    INTEGER :: BOUNDARY_CLUSTER1(:,:)
    
    INTEGER :: CLUSTER_FLAG2
    INTEGER :: BOUNDARY_CLUSTER2(:,:)
    
    INTEGER :: BOUNDARY_PAIR_NUM
    INTEGER :: BOUNDARY_PAIR(:,:)
    
    INTEGER :: CORNER_PAIR_NUM
    INTEGER :: CORNER_PAIR(:,:)
    
    INTEGER :: BOUNDARY_CLUSTER_FLAG1, BOUNDARY_CLUSTER_FLAG2
    INTEGER :: I, I0, K0, I1, K1, ITER
    
    TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT
    
    IF (TYP==0) THEN
        SURFACE_CURRENT => SURFACE_FLUID
    END IF
    IF (TYP==1) THEN
        SURFACE_CURRENT => SURFACE_PROPEL
    END IF
    IF (TYP==2) THEN
        SURFACE_CURRENT => SURFACE_CASE
    END IF
    
    
    CORNER_PAIR_NUM = 0
    CORNER_PAIR(:,:) = 0
    
    DO ITER = 1,BOUNDARY_PAIR_NUM
    
    BOUNDARY_CLUSTER_FLAG1 = BOUNDARY_PAIR(1,ITER)
    BOUNDARY_CLUSTER_FLAG2 = BOUNDARY_PAIR(2,ITER)
    
    K0 = MOD(BOUNDARY_CLUSTER2(1,BOUNDARY_CLUSTER_FLAG2),3)+1
    I0 = (BOUNDARY_CLUSTER2(1,BOUNDARY_CLUSTER_FLAG2) - MOD(BOUNDARY_CLUSTER2(1,BOUNDARY_CLUSTER_FLAG2),3))/3
    
    I = 1
    DO WHILE(BOUNDARY_CLUSTER2(I+1,BOUNDARY_CLUSTER_FLAG2) .NE. 0)
        I = I + 1
    END DO
    
    K1 = MOD(BOUNDARY_CLUSTER2(I,BOUNDARY_CLUSTER_FLAG2),3)+1
    I1 = (BOUNDARY_CLUSTER2(I,BOUNDARY_CLUSTER_FLAG2) - MOD(BOUNDARY_CLUSTER2(I,BOUNDARY_CLUSTER_FLAG2),3))/3
    
    IF(SURFACE_CURRENT%SURFACE_FACES(K0,I0) .NE. SURFACE_CURRENT%SURFACE_FACES(MOD(K1,3)+1,I1)) THEN
    
    CORNER_PAIR_NUM = CORNER_PAIR_NUM + 1
    
    !CORNER_PAIR(1,CORNER_PAIR_NUM) = I1 * 3 + MOD(K1,3) + 1 - 1
    
    CORNER_PAIR(1,CORNER_PAIR_NUM) = SURFACE_CURRENT%SURFACE_FACES(MOD(K1,3) + 1, I1)
    
    K0 = MOD(BOUNDARY_CLUSTER1(1,BOUNDARY_CLUSTER_FLAG1),3)+1
    I0 = (BOUNDARY_CLUSTER1(1,BOUNDARY_CLUSTER_FLAG1) - MOD(BOUNDARY_CLUSTER1(1,BOUNDARY_CLUSTER_FLAG1),3))/3
    
    !CORNER_PAIR(2,CORNER_PAIR_NUM) = I0 * 3 + K0 - 1
    
    CORNER_PAIR(2,CORNER_PAIR_NUM) = SURFACE_CURRENT%SURFACE_FACES(K0,I0)
    
    END IF
    
    END DO
    
    END SUBROUTINE
    
    SUBROUTINE CONNECTING_CORNER_CLUSTER(TYP, CORNER_PAIR, CORNER_PAIR_FLAG, CORNER_CONNECTION_CLUSTER)
    IMPLICIT NONE
    INTEGER :: TYP
    INTEGER :: CORNER_PAIR(:,:)
    INTEGER :: CORNER_PAIR_FLAG
    
    INTEGER :: CORNER_CONNECTION_CLUSTER(:,:)
    
    INTEGER :: POINT_START, POINT_END, CURRENT_POINT, NEXT_POINT, TEMP_POINT
    
    INTEGER :: I,T,L,I0,K0,I1
    
    REAL(8) :: RMIN, R
    
    INTEGER :: TEMP_CLUSTER_NUM
    INTEGER, ALLOCATABLE :: TEMP_CLUSTER(:)
    
    TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT
    
    IF (TYP==0) THEN
        SURFACE_CURRENT => SURFACE_FLUID
    END IF
    IF (TYP==1) THEN
        SURFACE_CURRENT => SURFACE_PROPEL
    END IF
    IF (TYP==2) THEN
        SURFACE_CURRENT => SURFACE_CASE
    END IF
    
    CORNER_CONNECTION_CLUSTER(:,CORNER_PAIR_FLAG) = 0
    
    POINT_START = CORNER_PAIR(1,CORNER_PAIR_FLAG)
    POINT_END = CORNER_PAIR(2,CORNER_PAIR_FLAG)
    
    ALLOCATE(TEMP_CLUSTER(SURFACE_CURRENT%SURFACE_POINTS_NUM))
    TEMP_CLUSTER(:) = 0
    TEMP_CLUSTER_NUM = 0
    
    CURRENT_POINT = POINT_START
    
    DO WHILE(CURRENT_POINT .NE. POINT_END .AND. TEMP_CLUSTER_NUM < 10)
    
    TEMP_CLUSTER_NUM = TEMP_CLUSTER_NUM + 1
    
    RMIN = MAX(DOMAIN_MAX(1) - DOMAIN_MIN(1), DOMAIN_MAX(2) - DOMAIN_MIN(2), DOMAIN_MAX(3) - DOMAIN_MIN(3))
    
    DO T=1,SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(CURRENT_POINT)
        I1 = SURFACE_CURRENT%POINT_FACE_CONNECTION(T,CURRENT_POINT)
        
        DO L=1,3
            IF(CURRENT_POINT == SURFACE_CURRENT%SURFACE_FACES(L,I1)) THEN
                EXIT
            END IF
        END DO
        
        TEMP_POINT = SURFACE_CURRENT%SURFACE_FACES(MOD(L,3)+1,I1)
        
        R = SQRT(DOT_PRODUCT(SURFACE_CURRENT%SURFACE_POINTS(:,POINT_END) - SURFACE_CURRENT%SURFACE_POINTS(:,TEMP_POINT), SURFACE_CURRENT%SURFACE_POINTS(:,POINT_END) - SURFACE_CURRENT%SURFACE_POINTS(:,TEMP_POINT) ))
        
        IF(R < RMIN) THEN
            RMIN = R
            NEXT_POINT = TEMP_POINT
            TEMP_CLUSTER(TEMP_CLUSTER_NUM) = I1 * 3 + L - 1
        END IF
    END DO
    
    CURRENT_POINT = NEXT_POINT
    
    END DO
    
    IF(TEMP_CLUSTER_NUM < 10) THEN
        DO I=2,TEMP_CLUSTER_NUM
            K0 = MOD(TEMP_CLUSTER(I),3)+1
            I0 = (TEMP_CLUSTER(I) - MOD(TEMP_CLUSTER(I),3))/3
            
            CALL PROJECTION_EDGE_POINT(SURFACE_CURRENT%SURFACE_POINTS(:,SURFACE_CURRENT%SURFACE_FACES(K0,I0)),SURFACE_CURRENT%SURFACE_POINTS(:,POINT_START),SURFACE_CURRENT%SURFACE_POINTS(:,POINT_END),R)
        END DO
        
        CORNER_CONNECTION_CLUSTER(1:TEMP_CLUSTER_NUM, CORNER_PAIR_FLAG) = TEMP_CLUSTER(1:TEMP_CLUSTER_NUM)
    END IF
    
    DEALLOCATE(TEMP_CLUSTER)
    
    END SUBROUTINE
    
    SUBROUTINE ADDING_REMOVE_FACE(TYP, CLUSTER_FLAG1, BOUNDARY_CLUSTER1, CLUSTER_FLAG2, BOUNDARY_CLUSTER2, BOUNDARY_PAIR, BOUNDARY_PAIR_FLAG, CORNER_PAIR_NUM, CORNER_PAIR, CORNER_CONNECTION_CLUSTER, B_REMOVE_FACE, FLAG)
    IMPLICIT NONE
    INTEGER :: TYP
    INTEGER :: CLUSTER_FLAG1
    INTEGER :: BOUNDARY_CLUSTER1(:,:)
    
    INTEGER :: CLUSTER_FLAG2
    INTEGER :: BOUNDARY_CLUSTER2(:,:)
    
    INTEGER :: BOUNDARY_PAIR(:,:)
    INTEGER :: BOUNDARY_PAIR_FLAG
    
    INTEGER :: CORNER_PAIR_NUM
    INTEGER :: CORNER_PAIR(:,:)
    
    INTEGER :: CORNER_CONNECTION_CLUSTER(:,:)
    
    LOGICAL :: B_REMOVE_FACE(:)
    LOGICAL :: FLAG
    
    INTEGER :: BOUNDARY_CLUSTER_FLAG1, BOUNDARY_CLUSTER_FLAG2
    INTEGER :: CORNER_START1, CORNER_END1, CORNER_START2, CORNER_END2, CORNER_PAIR_INDEX1, CORNER_PAIR_INDEX2
    INTEGER :: I, K, L, I0, K0, I1, K1
    
    LOGICAL :: B
    
    INTEGER :: REGION_FLAG, FACE_START
    
    LOGICAL, ALLOCATABLE :: BOUNDARY_WALL(:,:)
    INTEGER :: TEMP_CLUSTER_NUM, CURRENT_CLUSTER_NUM
    INTEGER, ALLOCATABLE :: TEMP_CLUSTER(:)
    LOGICAL, ALLOCATABLE :: USED_FACE(:)
    
    TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT
    
    IF (TYP==0) THEN
        SURFACE_CURRENT => SURFACE_FLUID
    END IF
    IF (TYP==1) THEN
        SURFACE_CURRENT => SURFACE_PROPEL
    END IF
    IF (TYP==2) THEN
        SURFACE_CURRENT => SURFACE_CASE
    END IF
    
    
    !! BOUNDARY_CLUSTER_FLAG1 == BOUNDARY_CLUSTER_FLAG2 CASE?
    
    
    
    FLAG = .FALSE.
    
    BOUNDARY_CLUSTER_FLAG1 = BOUNDARY_PAIR(1,BOUNDARY_PAIR_FLAG)
    BOUNDARY_CLUSTER_FLAG2 = BOUNDARY_PAIR(2,BOUNDARY_PAIR_FLAG)
    
    K0 = MOD(BOUNDARY_CLUSTER1(1,BOUNDARY_CLUSTER_FLAG1),3)+1
    I0 = (BOUNDARY_CLUSTER1(1,BOUNDARY_CLUSTER_FLAG1) - MOD(BOUNDARY_CLUSTER1(1,BOUNDARY_CLUSTER_FLAG1),3))/3
    
    I = 1
    DO WHILE(BOUNDARY_CLUSTER1(I+1,BOUNDARY_CLUSTER_FLAG1) .NE. 0)
        I = I + 1
    END DO
    
    K1 = MOD(BOUNDARY_CLUSTER1(I,BOUNDARY_CLUSTER_FLAG1),3)+1
    I1 = (BOUNDARY_CLUSTER1(I,BOUNDARY_CLUSTER_FLAG1) - MOD(BOUNDARY_CLUSTER1(I,BOUNDARY_CLUSTER_FLAG1),3))/3
    
    CORNER_START1 = SURFACE_CURRENT%SURFACE_FACES(MOD(K1,3) + 1, I1)
    CORNER_END2 = SURFACE_CURRENT%SURFACE_FACES(K0,I0)
    
    
    K0 = MOD(BOUNDARY_CLUSTER2(1,BOUNDARY_CLUSTER_FLAG2),3)+1
    I0 = (BOUNDARY_CLUSTER2(1,BOUNDARY_CLUSTER_FLAG2) - MOD(BOUNDARY_CLUSTER2(1,BOUNDARY_CLUSTER_FLAG2),3))/3
    
    I = 1
    DO WHILE(BOUNDARY_CLUSTER2(I+1,BOUNDARY_CLUSTER_FLAG2) .NE. 0)
        I = I + 1
    END DO
    
    K1 = MOD(BOUNDARY_CLUSTER2(I,BOUNDARY_CLUSTER_FLAG2),3)+1
    I1 = (BOUNDARY_CLUSTER2(I,BOUNDARY_CLUSTER_FLAG2) - MOD(BOUNDARY_CLUSTER2(I,BOUNDARY_CLUSTER_FLAG2),3))/3
    
    CORNER_START2 = SURFACE_CURRENT%SURFACE_FACES(MOD(K1,3) + 1, I1)
    CORNER_END1 = SURFACE_CURRENT%SURFACE_FACES(K0,I0)
    
    CORNER_PAIR_INDEX1 = 0
    CORNER_PAIR_INDEX2 = 0
    
    DO I=1,CORNER_PAIR_NUM
        IF((CORNER_PAIR(1,I)==CORNER_START1 .AND. CORNER_PAIR(2,I)==CORNER_END1) .OR. (CORNER_PAIR(2,I)==CORNER_START1 .AND. CORNER_PAIR(1,I)==CORNER_END1)) THEN
            CORNER_PAIR_INDEX1 = I
        ELSE IF((CORNER_PAIR(1,I)==CORNER_START2 .AND. CORNER_PAIR(2,I)==CORNER_END2) .OR. (CORNER_PAIR(2,I)==CORNER_START2 .AND. CORNER_PAIR(1,I)==CORNER_END2)) THEN
            CORNER_PAIR_INDEX2 = I
        END IF
    END DO
    
    IF(CORNER_PAIR_INDEX1 .NE. 0 .AND. CORNER_PAIR_INDEX2 .NE. 0) THEN
    IF(CORNER_CONNECTION_CLUSTER(1,CORNER_PAIR_INDEX1) == 0 .OR. CORNER_CONNECTION_CLUSTER(1,CORNER_PAIR_INDEX2) == 0) THEN
        RETURN
    END IF
    END IF
    
    
    REGION_FLAG = 0
    FACE_START = 0
    
    I = 1
    DO WHILE(BOUNDARY_CLUSTER1(I,BOUNDARY_CLUSTER_FLAG1) .NE. 0)
        K0 = MOD(BOUNDARY_CLUSTER1(I,BOUNDARY_CLUSTER_FLAG1),3)+1
        I0 = (BOUNDARY_CLUSTER1(I,BOUNDARY_CLUSTER_FLAG1) - MOD(BOUNDARY_CLUSTER1(I,BOUNDARY_CLUSTER_FLAG1),3))/3
        
        CALL FACE_NEIGHBOR_FACE(SURFACE_CURRENT%SURFACE_FACES, SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM, SURFACE_CURRENT%POINT_FACE_CONNECTION,I0,K0, I1)
        
        IF(REGION_FLAG==0) THEN
            FACE_START = I1
            REGION_FLAG = SURFACE_CURRENT%FACE_DIVIDED_REGION_ARRAY(I1)
        ELSE IF(REGION_FLAG .NE. SURFACE_CURRENT%FACE_DIVIDED_REGION_ARRAY(I1)) THEN
            RETURN
        END IF
        
        I = I + 1
    END DO    
    
    
    I = 1
    DO WHILE(BOUNDARY_CLUSTER2(I,BOUNDARY_CLUSTER_FLAG2) .NE. 0)
        K0 = MOD(BOUNDARY_CLUSTER2(I,BOUNDARY_CLUSTER_FLAG2),3)+1
        I0 = (BOUNDARY_CLUSTER2(I,BOUNDARY_CLUSTER_FLAG2) - MOD(BOUNDARY_CLUSTER2(I,BOUNDARY_CLUSTER_FLAG2),3))/3
        
        CALL FACE_NEIGHBOR_FACE(SURFACE_CURRENT%SURFACE_FACES, SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM, SURFACE_CURRENT%POINT_FACE_CONNECTION,I0,K0, I1)
        
        IF(REGION_FLAG==0) THEN
            FACE_START = I1
            REGION_FLAG = SURFACE_CURRENT%FACE_DIVIDED_REGION_ARRAY(I1)
        ELSE IF(REGION_FLAG .NE. SURFACE_CURRENT%FACE_DIVIDED_REGION_ARRAY(I1)) THEN
            RETURN
        END IF
        
        I = I + 1
    END DO
    
    
    
    ALLOCATE(BOUNDARY_WALL(3,SURFACE_CURRENT%SURFACE_FACES_NUM))
    BOUNDARY_WALL(:,:) = .FALSE.
    
    I = 1
    DO WHILE(BOUNDARY_CLUSTER1(I,BOUNDARY_CLUSTER_FLAG1) .NE. 0)
        K0 = MOD(BOUNDARY_CLUSTER1(I,BOUNDARY_CLUSTER_FLAG1),3)+1
        I0 = (BOUNDARY_CLUSTER1(I,BOUNDARY_CLUSTER_FLAG1) - MOD(BOUNDARY_CLUSTER1(I,BOUNDARY_CLUSTER_FLAG1),3))/3
        
        BOUNDARY_WALL(K0,I0) = .TRUE.
        
        CALL FACE_NEIGHBOR_FACE(SURFACE_CURRENT%SURFACE_FACES, SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM, SURFACE_CURRENT%POINT_FACE_CONNECTION,I0,K0, I1)
        DO L=1,3
            IF(SURFACE_CURRENT%SURFACE_FACES(K0,I0) == SURFACE_CURRENT%SURFACE_FACES(MOD(L,3)+1,I1)) THEN
                EXIT
            END IF
        END DO
        
        BOUNDARY_WALL(L,I1) = .TRUE.
        
        I = I+1
    END DO
    
    I = 1
    DO WHILE(BOUNDARY_CLUSTER2(I,BOUNDARY_CLUSTER_FLAG2) .NE. 0)
        K0 = MOD(BOUNDARY_CLUSTER2(I,BOUNDARY_CLUSTER_FLAG2),3)+1
        I0 = (BOUNDARY_CLUSTER2(I,BOUNDARY_CLUSTER_FLAG2) - MOD(BOUNDARY_CLUSTER2(I,BOUNDARY_CLUSTER_FLAG2),3))/3
        
        BOUNDARY_WALL(K0,I0) = .TRUE.
        
        CALL FACE_NEIGHBOR_FACE(SURFACE_CURRENT%SURFACE_FACES, SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM, SURFACE_CURRENT%POINT_FACE_CONNECTION,I0,K0, I1)
        DO L=1,3
            IF(SURFACE_CURRENT%SURFACE_FACES(K0,I0) == SURFACE_CURRENT%SURFACE_FACES(MOD(L,3)+1,I1)) THEN
                EXIT
            END IF
        END DO
        
        BOUNDARY_WALL(L,I1) = .TRUE.
        
        I = I+1
    END DO
    
    I = 1
    DO WHILE(CORNER_CONNECTION_CLUSTER(I,CORNER_PAIR_INDEX1) .NE. 0)
        K0 = MOD(CORNER_CONNECTION_CLUSTER(I,CORNER_PAIR_INDEX1),3)+1
        I0 = (CORNER_CONNECTION_CLUSTER(I,CORNER_PAIR_INDEX1) - MOD(CORNER_CONNECTION_CLUSTER(I,CORNER_PAIR_INDEX1),3))/3
        
        BOUNDARY_WALL(K0,I0) = .TRUE.
        
        CALL FACE_NEIGHBOR_FACE(SURFACE_CURRENT%SURFACE_FACES, SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM, SURFACE_CURRENT%POINT_FACE_CONNECTION,I0,K0, I1)
        DO L=1,3
            IF(SURFACE_CURRENT%SURFACE_FACES(K0,I0) == SURFACE_CURRENT%SURFACE_FACES(MOD(L,3)+1,I1)) THEN
                EXIT
            END IF
        END DO
        
        BOUNDARY_WALL(L,I1) = .TRUE.
        
        I = I+1
    END DO
    
    I = 1
    DO WHILE(CORNER_CONNECTION_CLUSTER(I,CORNER_PAIR_INDEX2) .NE. 0)
        K0 = MOD(CORNER_CONNECTION_CLUSTER(I,CORNER_PAIR_INDEX2),3)+1
        I0 = (CORNER_CONNECTION_CLUSTER(I,CORNER_PAIR_INDEX2) - MOD(CORNER_CONNECTION_CLUSTER(I,CORNER_PAIR_INDEX2),3))/3
        
        BOUNDARY_WALL(K0,I0) = .TRUE.
        
        CALL FACE_NEIGHBOR_FACE(SURFACE_CURRENT%SURFACE_FACES, SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM, SURFACE_CURRENT%POINT_FACE_CONNECTION,I0,K0, I1)
        DO L=1,3
            IF(SURFACE_CURRENT%SURFACE_FACES(K0,I0) == SURFACE_CURRENT%SURFACE_FACES(MOD(L,3)+1,I1)) THEN
                EXIT
            END IF
        END DO
        
        BOUNDARY_WALL(L,I1) = .TRUE.
        
        I = I+1
    END DO
    
    ALLOCATE(TEMP_CLUSTER(SURFACE_CURRENT%SURFACE_FACES_NUM), USED_FACE(SURFACE_CURRENT%SURFACE_FACES_NUM))
    TEMP_CLUSTER_NUM = 0
    TEMP_CLUSTER(:) = 0
    USED_FACE(:) = .FALSE.
    
    
    
    CURRENT_CLUSTER_NUM = 1
    TEMP_CLUSTER_NUM = 1
    TEMP_CLUSTER(TEMP_CLUSTER_NUM) = FACE_START
    USED_FACE(FACE_START) = .TRUE.
    
    B = .TRUE.
    DO WHILE(B)
        B = .FALSE.
        
        DO I = 1,CURRENT_CLUSTER_NUM
            I0 = TEMP_CLUSTER(I)
            
            DO K=1,3
                IF(.NOT. BOUNDARY_WALL(K,I0)) THEN
                
                CALL FACE_NEIGHBOR_FACE(SURFACE_CURRENT%SURFACE_FACES, SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM, SURFACE_CURRENT%POINT_FACE_CONNECTION,I0,K, I1)
                
                IF(SURFACE_CURRENT%FACE_DIVIDED_REGION_ARRAY(I1) .NE. REGION_FLAG) THEN
                    DEALLOCATE(TEMP_CLUSTER, USED_FACE)
                    DEALLOCATE(BOUNDARY_WALL)
                    RETURN
                END IF
                
                IF(.NOT. USED_FACE(I1)) THEN
                    B = .TRUE.
                    TEMP_CLUSTER_NUM = TEMP_CLUSTER_NUM + 1
                    TEMP_CLUSTER(TEMP_CLUSTER_NUM) = I1
                    USED_FACE(I1) = .TRUE.
                END IF
                
                END IF
            END DO
        END DO
        
        CURRENT_CLUSTER_NUM = TEMP_CLUSTER_NUM
        
    END DO
    
    DO I=1,TEMP_CLUSTER_NUM
        B_REMOVE_FACE(TEMP_CLUSTER(I)) = .TRUE.
    END DO
    
    FLAG = .TRUE.
    
    DEALLOCATE(TEMP_CLUSTER, USED_FACE)
    DEALLOCATE(BOUNDARY_WALL)
    
    END SUBROUTINE
    
    SUBROUTINE FIND_BOUNDARY_TO_ZIPPER(TYP, CLUSTER_FLAG1, BOUNDARY_CLUSTER1, CLUSTER_FLAG2, BOUNDARY_CLUSTER2, BOUNDARY_PAIR, BOUNDARY_PAIR_FLAG, CORNER_PAIR_NUM, CORNER_PAIR, CORNER_CONNECTION_CLUSTER, BOUNDARY_ZIPPER_POINT_NUM1, BOUNDARY_ZIPPER_POINT1, BOUNDARY_ZIPPER_POINT_NUM2, BOUNDARY_ZIPPER_POINT2)
    IMPLICIT NONE
    INTEGER :: TYP
    INTEGER :: CLUSTER_FLAG1
    INTEGER :: BOUNDARY_CLUSTER1(:,:)
    
    INTEGER :: CLUSTER_FLAG2
    INTEGER :: BOUNDARY_CLUSTER2(:,:)
    
    INTEGER :: BOUNDARY_PAIR(:,:)
    INTEGER :: BOUNDARY_PAIR_FLAG
    
    INTEGER :: CORNER_PAIR_NUM
    INTEGER :: CORNER_PAIR(:,:)
    
    INTEGER :: CORNER_CONNECTION_CLUSTER(:,:)
    
    INTEGER :: BOUNDARY_ZIPPER_POINT_NUM1
    INTEGER :: BOUNDARY_ZIPPER_POINT1(:)
    
    INTEGER :: BOUNDARY_ZIPPER_POINT_NUM2
    INTEGER :: BOUNDARY_ZIPPER_POINT2(:)
    
    INTEGER :: BOUNDARY_CLUSTER_FLAG1, BOUNDARY_CLUSTER_FLAG2
    INTEGER :: CORNER_START1, CORNER_END1, CORNER_START2, CORNER_END2, CORNER_PAIR_INDEX1, CORNER_PAIR_INDEX2
    INTEGER :: I, NUM, I0, K0, I1, K1
    
    TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT
    
    IF (TYP==0) THEN
        SURFACE_CURRENT => SURFACE_FLUID
    END IF
    IF (TYP==1) THEN
        SURFACE_CURRENT => SURFACE_PROPEL
    END IF
    IF (TYP==2) THEN
        SURFACE_CURRENT => SURFACE_CASE
    END IF
    
    
    BOUNDARY_CLUSTER_FLAG1 = BOUNDARY_PAIR(1,BOUNDARY_PAIR_FLAG)
    BOUNDARY_CLUSTER_FLAG2 = BOUNDARY_PAIR(2,BOUNDARY_PAIR_FLAG)
    
    K0 = MOD(BOUNDARY_CLUSTER1(1,BOUNDARY_CLUSTER_FLAG1),3)+1
    I0 = (BOUNDARY_CLUSTER1(1,BOUNDARY_CLUSTER_FLAG1) - MOD(BOUNDARY_CLUSTER1(1,BOUNDARY_CLUSTER_FLAG1),3))/3
    
    I = 1
    DO WHILE(BOUNDARY_CLUSTER1(I+1,BOUNDARY_CLUSTER_FLAG1) .NE. 0)
        I = I + 1
    END DO
    
    K1 = MOD(BOUNDARY_CLUSTER1(I,BOUNDARY_CLUSTER_FLAG1),3)+1
    I1 = (BOUNDARY_CLUSTER1(I,BOUNDARY_CLUSTER_FLAG1) - MOD(BOUNDARY_CLUSTER1(I,BOUNDARY_CLUSTER_FLAG1),3))/3
    
    CORNER_START1 = SURFACE_CURRENT%SURFACE_FACES(MOD(K1,3) + 1, I1)
    CORNER_END2 = SURFACE_CURRENT%SURFACE_FACES(K0,I0)
    
    
    K0 = MOD(BOUNDARY_CLUSTER2(1,BOUNDARY_CLUSTER_FLAG2),3)+1
    I0 = (BOUNDARY_CLUSTER2(1,BOUNDARY_CLUSTER_FLAG2) - MOD(BOUNDARY_CLUSTER2(1,BOUNDARY_CLUSTER_FLAG2),3))/3
    
    I = 1
    DO WHILE(BOUNDARY_CLUSTER2(I+1,BOUNDARY_CLUSTER_FLAG2) .NE. 0)
        I = I + 1
    END DO
    
    K1 = MOD(BOUNDARY_CLUSTER2(I,BOUNDARY_CLUSTER_FLAG2),3)+1
    I1 = (BOUNDARY_CLUSTER2(I,BOUNDARY_CLUSTER_FLAG2) - MOD(BOUNDARY_CLUSTER2(I,BOUNDARY_CLUSTER_FLAG2),3))/3
    
    CORNER_START2 = SURFACE_CURRENT%SURFACE_FACES(MOD(K1,3) + 1, I1)
    CORNER_END1 = SURFACE_CURRENT%SURFACE_FACES(K0,I0)
    
    CORNER_PAIR_INDEX1 = 0
    CORNER_PAIR_INDEX2 = 0
    
    DO I=1,CORNER_PAIR_NUM
        IF((CORNER_PAIR(1,I)==CORNER_START1 .AND. CORNER_PAIR(2,I)==CORNER_END1) .OR. (CORNER_PAIR(2,I)==CORNER_START1 .AND. CORNER_PAIR(1,I)==CORNER_END1)) THEN
            CORNER_PAIR_INDEX1 = I
        ELSE IF((CORNER_PAIR(1,I)==CORNER_START2 .AND. CORNER_PAIR(2,I)==CORNER_END2) .OR. (CORNER_PAIR(2,I)==CORNER_START2 .AND. CORNER_PAIR(1,I)==CORNER_END2)) THEN
            CORNER_PAIR_INDEX2 = I
        END IF
    END DO
    
    
    
    BOUNDARY_ZIPPER_POINT_NUM1 = 0
    BOUNDARY_ZIPPER_POINT1(:) = 0
    
    BOUNDARY_ZIPPER_POINT_NUM2 = 0
    BOUNDARY_ZIPPER_POINT2(:) = 0
    
    I = 1
    DO WHILE(BOUNDARY_CLUSTER1(I,BOUNDARY_CLUSTER_FLAG1) .NE. 0)
        K0 = MOD(BOUNDARY_CLUSTER1(I,BOUNDARY_CLUSTER_FLAG1),3)+1
        I0 = (BOUNDARY_CLUSTER1(I,BOUNDARY_CLUSTER_FLAG1) - MOD(BOUNDARY_CLUSTER1(I,BOUNDARY_CLUSTER_FLAG1),3))/3
        
        BOUNDARY_ZIPPER_POINT_NUM1 = BOUNDARY_ZIPPER_POINT_NUM1 + 1
        BOUNDARY_ZIPPER_POINT1(BOUNDARY_ZIPPER_POINT_NUM1) = SURFACE_CURRENT%SURFACE_FACES(K0,I0)
        
        I = I + 1
    END DO
    
    
    
    !! CORNER_PAIR_INDEX1 == 0 CASE?
    
    IF(CORNER_CONNECTION_CLUSTER(1,CORNER_PAIR_INDEX1) == 0) THEN
    
    BOUNDARY_ZIPPER_POINT_NUM1 = BOUNDARY_ZIPPER_POINT_NUM1 + 1
    BOUNDARY_ZIPPER_POINT1(BOUNDARY_ZIPPER_POINT_NUM1) = SURFACE_CURRENT%SURFACE_FACES(MOD(K0,3)+1,I0)
    
    ELSE
    
    IF(CORNER_PAIR(1,CORNER_PAIR_INDEX1)==CORNER_START1) THEN
    
    I = 1
    DO WHILE(CORNER_CONNECTION_CLUSTER(I,CORNER_PAIR_INDEX1) .NE. 0)
        K0 = MOD(CORNER_CONNECTION_CLUSTER(I,CORNER_PAIR_INDEX1),3)+1
        I0 = (CORNER_CONNECTION_CLUSTER(I,CORNER_PAIR_INDEX1) - MOD(CORNER_CONNECTION_CLUSTER(I,CORNER_PAIR_INDEX1),3))/3
        
        BOUNDARY_ZIPPER_POINT_NUM1 = BOUNDARY_ZIPPER_POINT_NUM1 + 1
        BOUNDARY_ZIPPER_POINT1(BOUNDARY_ZIPPER_POINT_NUM1) = SURFACE_CURRENT%SURFACE_FACES(K0,I0)
        
        I = I + 1
    END DO
    
    ELSE
    
    NUM = 1
    DO WHILE(CORNER_CONNECTION_CLUSTER(NUM+1,CORNER_PAIR_INDEX1) .NE. 0)
        NUM = NUM + 1
    END DO
    
    DO I=NUM,1,-1
        K0 = MOD(CORNER_CONNECTION_CLUSTER(I,CORNER_PAIR_INDEX1),3)+1
        I0 = (CORNER_CONNECTION_CLUSTER(I,CORNER_PAIR_INDEX1) - MOD(CORNER_CONNECTION_CLUSTER(I,CORNER_PAIR_INDEX1),3))/3
        
        BOUNDARY_ZIPPER_POINT_NUM1 = BOUNDARY_ZIPPER_POINT_NUM1 + 1
        BOUNDARY_ZIPPER_POINT1(BOUNDARY_ZIPPER_POINT_NUM1) = SURFACE_CURRENT%SURFACE_FACES(MOD(K0,3)+1,I0)
    END DO
    
    END IF
    
    END IF
    
    
    
    I = 1
    DO WHILE(BOUNDARY_CLUSTER2(I,BOUNDARY_CLUSTER_FLAG2) .NE. 0)
        K0 = MOD(BOUNDARY_CLUSTER2(I,BOUNDARY_CLUSTER_FLAG2),3)+1
        I0 = (BOUNDARY_CLUSTER2(I,BOUNDARY_CLUSTER_FLAG2) - MOD(BOUNDARY_CLUSTER2(I,BOUNDARY_CLUSTER_FLAG2),3))/3
        
        BOUNDARY_ZIPPER_POINT_NUM1 = BOUNDARY_ZIPPER_POINT_NUM1 + 1
        BOUNDARY_ZIPPER_POINT1(BOUNDARY_ZIPPER_POINT_NUM1) = SURFACE_CURRENT%SURFACE_FACES(K0,I0)
        
        I = I + 1
    END DO
    
    
    
    !! CORNER_PAIR_INDEX2 == 0 CASE?
    
    IF(CORNER_CONNECTION_CLUSTER(1,CORNER_PAIR_INDEX2) == 0) THEN
    
    BOUNDARY_ZIPPER_POINT_NUM1 = BOUNDARY_ZIPPER_POINT_NUM1 + 1
    BOUNDARY_ZIPPER_POINT1(BOUNDARY_ZIPPER_POINT_NUM1) = SURFACE_CURRENT%SURFACE_FACES(MOD(K0,3)+1,I0)
    
    ELSE
    
    IF(CORNER_PAIR(1,CORNER_PAIR_INDEX2)==CORNER_START2) THEN
    
    I = 1
    DO WHILE(CORNER_CONNECTION_CLUSTER(I,CORNER_PAIR_INDEX2) .NE. 0)
        K0 = MOD(CORNER_CONNECTION_CLUSTER(I,CORNER_PAIR_INDEX2),3)+1
        I0 = (CORNER_CONNECTION_CLUSTER(I,CORNER_PAIR_INDEX2) - MOD(CORNER_CONNECTION_CLUSTER(I,CORNER_PAIR_INDEX2),3))/3
        
        BOUNDARY_ZIPPER_POINT_NUM1 = BOUNDARY_ZIPPER_POINT_NUM1 + 1
        BOUNDARY_ZIPPER_POINT1(BOUNDARY_ZIPPER_POINT_NUM1) = SURFACE_CURRENT%SURFACE_FACES(K0,I0)
        
        I = I + 1
    END DO
    
    ELSE
    
    NUM = 1
    DO WHILE(CORNER_CONNECTION_CLUSTER(NUM+1,CORNER_PAIR_INDEX2) .NE. 0)
        NUM = NUM + 1
    END DO
    
    DO I=NUM,1,-1
        K0 = MOD(CORNER_CONNECTION_CLUSTER(I,CORNER_PAIR_INDEX2),3)+1
        I0 = (CORNER_CONNECTION_CLUSTER(I,CORNER_PAIR_INDEX2) - MOD(CORNER_CONNECTION_CLUSTER(I,CORNER_PAIR_INDEX2),3))/3
        
        BOUNDARY_ZIPPER_POINT_NUM1 = BOUNDARY_ZIPPER_POINT_NUM1 + 1
        BOUNDARY_ZIPPER_POINT1(BOUNDARY_ZIPPER_POINT_NUM1) = SURFACE_CURRENT%SURFACE_FACES(MOD(K0,3)+1,I0)
    END DO
    
    END IF
    
    END IF
    
    
    END SUBROUTINE
    

    SUBROUTINE MESH_TEST(POINT1,POINT2,POINT3,F_SHAPE)
    IMPLICIT NONE
    REAL(8) :: POINT1(3), POINT2(3), POINT3(3), F_SHAPE
    REAL(8) :: POINT_3D(3,3), V1(3), V2(3), N(3), POINT_2D(2,3)
    REAL(8) :: R, AREA, U(3), V(3), ALPHA, A(2,2), LAMBDA(2,2)
    INTEGER :: J,K
    
	POINT_3D(:,1) = POINT1
	POINT_3D(:,2) = POINT2
	POINT_3D(:,3) = POINT3

	V1 = POINT_3D(:,2)-POINT_3D(:,1)
	V2 = POINT_3D(:,3)-POINT_3D(:,1)

	CALL VEC_CURL1(V1,V2,N)

	R = SQRT(DOT_PRODUCT(N,N))

	AREA = R/2.
            
        IF(AREA > 0) THEN     
            N = N/R
            
            U = V1/SQRT(DOT_PRODUCT(V1,V1))
            CALL VEC_CURL1(N,U,V)
            
            POINT_2D(1,1) = DOT_PRODUCT(POINT_3D(:,1), U)
            POINT_2D(2,1) = DOT_PRODUCT(POINT_3D(:,1), V)
            
            POINT_2D(1,2) = DOT_PRODUCT(POINT_3D(:,2), U)
            POINT_2D(2,2) = DOT_PRODUCT(POINT_3D(:,2), V)
            
            POINT_2D(1,3) = DOT_PRODUCT(POINT_3D(:,3), U)
            POINT_2D(2,3) = DOT_PRODUCT(POINT_3D(:,3), V)
            
            A(1,1) = POINT_2D(1,2) - POINT_2D(1,1)
            A(1,2) = POINT_2D(1,3) - POINT_2D(1,1)
            A(2,1) = POINT_2D(2,2) - POINT_2D(2,1)
            A(2,2) = POINT_2D(2,3) - POINT_2D(2,1)
            
            ALPHA = A(1,1) * A(2,2) - A(1,2) * A(2,1)
            
            DO J = 1,2
                DO K = 1,2
                    LAMBDA(J,K) = A(1,J) * A(1,K) + A(2,J) * A(2,K)
                END DO
            END DO
            
            F_SHAPE = SQRT(3.) * ALPHA / (LAMBDA(1,1) + LAMBDA(2,2) - LAMBDA(1,2))
	ELSE
	    F_SHAPE = 0
	END IF
    END SUBROUTINE



    SUBROUTINE ATTACH_BOUNDARY(TYP, BOUNDARY1_NUM, BOUNDARY1, BOUNDARY2_NUM, BOUNDARY2)
    IMPLICIT NONE
    INTEGER :: TYP
    INTEGER :: BOUNDARY1_NUM, BOUNDARY2_NUM
    INTEGER, DIMENSION(:) :: BOUNDARY1, BOUNDARY2
    INTEGER :: TEMP_BOUNDARY1_NUM, TEMP_BOUNDARY2_NUM
    INTEGER :: BOUNDARY1_POINT_INDEX1, BOUNDARY1_POINT_INDEX2, BOUNDARY1_POINT_INDEX3, BOUNDARY2_POINT_INDEX1, BOUNDARY2_POINT_INDEX2
    REAL(8) :: BOUNDARY1_POINT1(3), BOUNDARY1_POINT2(3), BOUNDARY1_POINT3(3), BOUNDARY2_POINT1(3), BOUNDARY2_POINT2(3)
    REAL(8) :: DISTANCE1, DISTANCE2
    INTEGER, ALLOCATABLE :: TEMP_FACE(:,:), NEWFACE(:,:), TEMP_BOUNDARY1(:)
    INTEGER :: FACE_NUM, I, J
    INTEGER :: INDEX1, INDEX2, BOUNDARY_TEMP_INDEX1, BOUNDARY_TEMP_INDEX2
    REAL(8) :: BOUNDARY1_TEMP_POINT1(3), BOUNDARY1_TEMP_POINT2(3)
    REAL(8) :: F_SHAPE1, F_SHAPE2, MAX_F_SHAPE
    INTEGER :: MAX_MESH(3), TEMP_INDEX1, TEMP_INDEX2, TEMP
    TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT


    IF (TYP==0) THEN
	SURFACE_CURRENT => SURFACE_FLUID
    ELSE IF (TYP==1) THEN
	SURFACE_CURRENT => SURFACE_PROPEL
    ELSE
	SURFACE_CURRENT => SURFACE_FLUID
    END IF


    ALLOCATE(TEMP_FACE(3,1000))
    TEMP_FACE = 0

    TEMP_BOUNDARY1_NUM = 1
    TEMP_BOUNDARY2_NUM = 1
    FACE_NUM = 0
    IF (BOUNDARY2_NUM>0) THEN
	DO WHILE (TEMP_BOUNDARY1_NUM<BOUNDARY1_NUM+1 .AND. TEMP_BOUNDARY2_NUM<BOUNDARY1_NUM+1)
		BOUNDARY1_POINT_INDEX1 = BOUNDARY1(MOD(TEMP_BOUNDARY1_NUM-1,BOUNDARY1_NUM)+1)
		BOUNDARY1_POINT_INDEX2 = BOUNDARY1(MOD(TEMP_BOUNDARY1_NUM,BOUNDARY1_NUM)+1)
		BOUNDARY2_POINT_INDEX1 = BOUNDARY2(MOD(TEMP_BOUNDARY2_NUM-1,BOUNDARY2_NUM)+1)
		BOUNDARY2_POINT_INDEX2 = BOUNDARY2(MOD(TEMP_BOUNDARY2_NUM,BOUNDARY2_NUM)+1)
		BOUNDARY1_POINT1 = SURFACE_CURRENT%SURFACE_POINTS(:,BOUNDARY1_POINT_INDEX1)
		BOUNDARY1_POINT2 = SURFACE_CURRENT%SURFACE_POINTS(:,BOUNDARY1_POINT_INDEX2)
		BOUNDARY2_POINT1 = SURFACE_CURRENT%SURFACE_POINTS(:,BOUNDARY2_POINT_INDEX1)
		BOUNDARY2_POINT2 = SURFACE_CURRENT%SURFACE_POINTS(:,BOUNDARY2_POINT_INDEX2)

		DISTANCE1 = DOT_PRODUCT(BOUNDARY1_POINT1-BOUNDARY2_POINT2,BOUNDARY1_POINT1-BOUNDARY2_POINT2)
		DISTANCE2 = DOT_PRODUCT(BOUNDARY1_POINT2-BOUNDARY2_POINT1,BOUNDARY1_POINT2-BOUNDARY2_POINT1)

		IF (DISTANCE1<DISTANCE2) THEN
		    FACE_NUM = FACE_NUM + 1
		    TEMP_FACE(1, FACE_NUM) = BOUNDARY1_POINT_INDEX1
		    TEMP_FACE(2, FACE_NUM) = BOUNDARY2_POINT_INDEX1
		    TEMP_FACE(3, FACE_NUM) = BOUNDARY2_POINT_INDEX2

		    TEMP_BOUNDARY1_NUM = TEMP_BOUNDARY1_NUM
		    TEMP_BOUNDARY2_NUM = TEMP_BOUNDARY2_NUM + 1
		ELSE
		    FACE_NUM = FACE_NUM + 1
		    TEMP_FACE(1, FACE_NUM) = BOUNDARY2_POINT_INDEX1
		    TEMP_FACE(2, FACE_NUM) = BOUNDARY1_POINT_INDEX2
		    TEMP_FACE(3, FACE_NUM) = BOUNDARY1_POINT_INDEX1

		    TEMP_BOUNDARY1_NUM = TEMP_BOUNDARY1_NUM + 1
		    TEMP_BOUNDARY2_NUM = TEMP_BOUNDARY2_NUM
		END IF

		IF (TEMP_BOUNDARY1_NUM==BOUNDARY1_NUM+1 .AND. TEMP_BOUNDARY2_NUM<BOUNDARY2_NUM+1) THEN
		    DO WHILE(TEMP_BOUNDARY2_NUM<BOUNDARY2_NUM+1)
			FACE_NUM = FACE_NUM + 1
			BOUNDARY1_POINT_INDEX2 = BOUNDARY1(MOD(TEMP_BOUNDARY1_NUM-1,BOUNDARY1_NUM)+1)
			BOUNDARY2_POINT_INDEX1 = BOUNDARY2(MOD(TEMP_BOUNDARY2_NUM-1,BOUNDARY2_NUM)+1)
			BOUNDARY2_POINT_INDEX2 = BOUNDARY2(MOD(TEMP_BOUNDARY2_NUM,BOUNDARY2_NUM)+1)

			TEMP_FACE(1, FACE_NUM) = BOUNDARY1_POINT_INDEX2
			TEMP_FACE(2, FACE_NUM) = BOUNDARY2_POINT_INDEX1
			TEMP_FACE(3, FACE_NUM) = BOUNDARY2_POINT_INDEX2

			TEMP_BOUNDARY1_NUM = TEMP_BOUNDARY1_NUM
			TEMP_BOUNDARY2_NUM = TEMP_BOUNDARY2_NUM + 1
		    END DO
		END IF

		IF (TEMP_BOUNDARY1_NUM<BOUNDARY1_NUM+1 .AND. TEMP_BOUNDARY2_NUM==BOUNDARY2_NUM+1) THEN
		    DO WHILE(TEMP_BOUNDARY1_NUM<BOUNDARY1_NUM+1)
			FACE_NUM = FACE_NUM + 1
			BOUNDARY1_POINT_INDEX1 = BOUNDARY1(MOD(TEMP_BOUNDARY1_NUM-1,BOUNDARY1_NUM)+1)
			BOUNDARY1_POINT_INDEX2 = BOUNDARY1(MOD(TEMP_BOUNDARY1_NUM,BOUNDARY1_NUM)+1)
			BOUNDARY2_POINT_INDEX2 = BOUNDARY2(MOD(TEMP_BOUNDARY2_NUM-1,BOUNDARY2_NUM)+1)

			TEMP_FACE(1, FACE_NUM) = BOUNDARY2_POINT_INDEX2
			TEMP_FACE(2, FACE_NUM) = BOUNDARY1_POINT_INDEX2
			TEMP_FACE(3, FACE_NUM) = BOUNDARY1_POINT_INDEX1

			TEMP_BOUNDARY1_NUM = TEMP_BOUNDARY1_NUM + 1
			TEMP_BOUNDARY2_NUM = TEMP_BOUNDARY2_NUM
		    END DO
		END IF
	END DO
    ELSE
	ALLOCATE(TEMP_BOUNDARY1(BOUNDARY1_NUM))
	TEMP_BOUNDARY1 = BOUNDARY1
	TEMP_BOUNDARY1_NUM = 0
	MAX_F_SHAPE = 0

	DO WHILE (TEMP_BOUNDARY1_NUM<BOUNDARY1_NUM-2)
	    INDEX1 = 0
	    INDEX2 = 0
	    MAX_F_SHAPE = 0
	    DO I = 1, BOUNDARY1_NUM
		IF (TEMP_BOUNDARY1(MOD(I-1,BOUNDARY1_NUM)+1)>0 .AND. INDEX1==0) THEN
		    INDEX1 = MOD(I-1,BOUNDARY1_NUM)+1
		ELSE IF (TEMP_BOUNDARY1(MOD(I-1,BOUNDARY1_NUM)+1)>0 .AND. INDEX1>0) THEN
		    INDEX2 = MOD(I-1,BOUNDARY1_NUM)+1
		    EXIT
		END IF
	    END DO

	    DO I = 1, BOUNDARY1_NUM-TEMP_BOUNDARY1_NUM
		DO J = 1, BOUNDARY1_NUM
                    IF (TEMP_BOUNDARY1(MOD(INDEX1+BOUNDARY1_NUM-(J+1),BOUNDARY1_NUM) + 1)>0) THEN
                        TEMP_INDEX1 = MOD(INDEX1+BOUNDARY1_NUM-(J+1),BOUNDARY1_NUM) + 1
                        EXIT
                    END IF
                END DO
                DO J = 1, BOUNDARY1_NUM
                    IF (TEMP_BOUNDARY1(MOD(INDEX2+(J-1),BOUNDARY1_NUM) + 1)>0) THEN
                        TEMP_INDEX2 = MOD(INDEX2+(J-1),BOUNDARY1_NUM) + 1
                        EXIT
                    END IF
                END DO

		BOUNDARY_TEMP_INDEX1 = BOUNDARY1(TEMP_INDEX1)
		BOUNDARY_TEMP_INDEX2 = BOUNDARY1(TEMP_INDEX2)
		BOUNDARY1_TEMP_POINT1 = SURFACE_CURRENT%SURFACE_POINTS(:,BOUNDARY_TEMP_INDEX1)
		BOUNDARY1_TEMP_POINT2 = SURFACE_CURRENT%SURFACE_POINTS(:,BOUNDARY_TEMP_INDEX2)

		BOUNDARY1_POINT_INDEX1 = BOUNDARY1(INDEX1)
		BOUNDARY1_POINT_INDEX2 = BOUNDARY1(INDEX2)
		BOUNDARY1_POINT1 = SURFACE_CURRENT%SURFACE_POINTS(:,BOUNDARY1_POINT_INDEX1)
		BOUNDARY1_POINT2 = SURFACE_CURRENT%SURFACE_POINTS(:,BOUNDARY1_POINT_INDEX2)

		CALL MESH_TEST(BOUNDARY1_POINT1,BOUNDARY1_POINT2,BOUNDARY1_TEMP_POINT1,F_SHAPE1)
		CALL MESH_TEST(BOUNDARY1_POINT1,BOUNDARY1_POINT2,BOUNDARY1_TEMP_POINT2,F_SHAPE2)

		IF(MAX_F_SHAPE<F_SHAPE1) THEN
		    MAX_F_SHAPE = F_SHAPE1
		    MAX_MESH(1) = TEMP_INDEX1
		    MAX_MESH(2) = INDEX1
		    MAX_MESH(3) = INDEX2
		END IF

		IF(MAX_F_SHAPE<F_SHAPE2) THEN
		    MAX_F_SHAPE = F_SHAPE1
		    MAX_MESH(1) = INDEX1
		    MAX_MESH(2) = INDEX2
		    MAX_MESH(3) = TEMP_INDEX2
		END IF

		TEMP = INDEX1
		INDEX1 = 0		
		DO J = TEMP+1, BOUNDARY1_NUM+1
		    IF (TEMP_BOUNDARY1(MOD(J-1,BOUNDARY1_NUM)+1)>0 .AND. INDEX1==0) THEN
			INDEX1 = MOD(J-1,BOUNDARY1_NUM)+1
		    ELSE IF (TEMP_BOUNDARY1(MOD(J-1,BOUNDARY1_NUM)+1)>0 .AND. INDEX1>0) THEN
			INDEX2 = MOD(J-1,BOUNDARY1_NUM)+1
			EXIT
		     END IF
		END DO
	    END DO

	    FACE_NUM = FACE_NUM + 1
	    TEMP_FACE(1,FACE_NUM) = BOUNDARY1(MAX_MESH(1))
	    TEMP_FACE(2,FACE_NUM) = BOUNDARY1(MAX_MESH(2))
	    TEMP_FACE(3,FACE_NUM) = BOUNDARY1(MAX_MESH(3))
	    TEMP_BOUNDARY1(MAX_MESH(2)) = 0
	    TEMP_BOUNDARY1_NUM = TEMP_BOUNDARY1_NUM + 1

	END DO

	DEALLOCATE(TEMP_BOUNDARY1)
    END IF

    ALLOCATE(NEWFACE(3,SURFACE_CURRENT%SURFACE_FACES_NUM + FACE_NUM))
    !$OMP PARALLEL DO
    DO I = 1, SURFACE_CURRENT%SURFACE_FACES_NUM
	NEWFACE(:,I) = SURFACE_CURRENT%SURFACE_FACES(:,I)
    END DO
    !$OMP END PARALLEL DO

    DEALLOCATE(SURFACE_CURRENT%SURFACE_FACES)
    ALLOCATE(SURFACE_CURRENT%SURFACE_FACES(3,SURFACE_CURRENT%SURFACE_FACES_NUM + FACE_NUM))
    !$OMP PARALLEL DO
    DO I = 1, SURFACE_CURRENT%SURFACE_FACES_NUM + FACE_NUM
	IF (I<=SURFACE_CURRENT%SURFACE_FACES_NUM) THEN
	    SURFACE_CURRENT%SURFACE_FACES(:,I) = NEWFACE(:,I)
	ELSE
	    SURFACE_CURRENT%SURFACE_FACES(:,I) = TEMP_FACE(:,I-SURFACE_CURRENT%SURFACE_FACES_NUM)
	END IF
    END DO
    !$OMP END PARALLEL DO
    SURFACE_CURRENT%SURFACE_FACES_NUM = SURFACE_CURRENT%SURFACE_FACES_NUM + FACE_NUM


    DEALLOCATE(NEWFACE)
    DEALLOCATE(TEMP_FACE)
    END SUBROUTINE


    
    SUBROUTINE REMOVE_CERTAIN_FACES(TYP, B_REMOVE_FACE)
    IMPLICIT NONE
    
    INTEGER :: TYP
    LOGICAL :: B_REMOVE_FACE(:)
    
    INTEGER :: I, J
    LOGICAL :: B
    INTEGER :: NEWPOINT_NUM, NEWFACE_NUM
    REAL(8), ALLOCATABLE :: NEWPOINT(:,:) 
    INTEGER, ALLOCATABLE :: NEWFACE(:,:)
    INTEGER, ALLOCATABLE :: POINT_INDEX(:)
    INTEGER, ALLOCATABLE :: FACE_INDEX(:)
    
    TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT
    
    IF (TYP==0) THEN
        SURFACE_CURRENT => SURFACE_FLUID
    END IF
    IF (TYP==1) THEN
        SURFACE_CURRENT => SURFACE_PROPEL
    END IF
    IF (TYP==2) THEN
        SURFACE_CURRENT => SURFACE_CASE
    END IF
    
    ALLOCATE(NEWPOINT(3,SURFACE_CURRENT%SURFACE_POINTS_NUM))
    ALLOCATE(NEWFACE(3,SURFACE_CURRENT%SURFACE_FACES_NUM))
    ALLOCATE(POINT_INDEX(SURFACE_CURRENT%SURFACE_POINTS_NUM))
    ALLOCATE(FACE_INDEX(SURFACE_CURRENT%SURFACE_FACES_NUM))

    POINT_INDEX(:) = 0
    FACE_INDEX(:) = 0

    NEWPOINT_NUM = 0

    DO I = 1, SURFACE_CURRENT%SURFACE_POINTS_NUM
        B = .FALSE.
        DO J = 1, SURFACE_CURRENT%POINT_FACE_CONNECTION_NUM(I)
            IF(.NOT. B_REMOVE_FACE(SURFACE_CURRENT%POINT_FACE_CONNECTION(J,I))) THEN
                B = .TRUE.
            END IF
        END DO
        
        IF(B) THEN
            NEWPOINT_NUM = NEWPOINT_NUM+1
            NEWPOINT(:,NEWPOINT_NUM) = SURFACE_CURRENT%SURFACE_POINTS(:,I)
            POINT_INDEX(I) = NEWPOINT_NUM
        END IF
    END DO

    NEWFACE_NUM = 0

    DO J = 1, SURFACE_CURRENT%SURFACE_FACES_NUM
        IF(.NOT. B_REMOVE_FACE(J)) THEN
            NEWFACE_NUM = NEWFACE_NUM+1
            NEWFACE(:,NEWFACE_NUM) = SURFACE_CURRENT%SURFACE_FACES(:,J)
            FACE_INDEX(J) = NEWFACE_NUM
        END IF
    END DO

    CALL TEMP_NEW_POINTFACE_INDEX(TYP, NEWPOINT_NUM, NEWPOINT, NEWFACE_NUM, NEWFACE, POINT_INDEX, FACE_INDEX)

    !IF(TYP==1) THEN
    !    CALL CLASSIFY_PATCH(1)
    !END IF

    DEALLOCATE(NEWPOINT)
    DEALLOCATE(NEWFACE)
    DEALLOCATE(POINT_INDEX)
    DEALLOCATE(FACE_INDEX)
    
    END SUBROUTINE
    
    

    SUBROUTINE TEMP_NEW_POINTFACE_INDEX(TYP, NEWPOINT_NUM, NEWPOINT, NEWFACE_NUM, NEWFACE, POINT_INDEX, FACE_INDEX) !NEW_PATCH_NUM)!, NEW_PATCH_ZIPPER_TYPE)
    IMPLICIT NONE
    INTEGER :: TYP
    INTEGER :: NEWPOINT_NUM, NEWFACE_NUM
    REAL(8) :: NEWPOINT(3,NEWPOINT_NUM) 
    INTEGER :: NEWFACE(3,NEWFACE_NUM)
    !INTEGER :: NEW_PATCH_NUM
    INTEGER :: POINT_INDEX(:)
    INTEGER :: FACE_INDEX(:)
    INTEGER :: I,J
    !INTEGER :: NEW_PATCH_ZIPPER_TYPE(NEW_PATCH_NUM)
    TYPE(SURFACE_TYPE), POINTER :: SURFACE_CURRENT

    IF (TYP==0) THEN
        SURFACE_CURRENT => SURFACE_FLUID
    END IF
    IF (TYP==1) THEN
        SURFACE_CURRENT => SURFACE_PROPEL
    END IF
    IF (TYP==2) THEN
        SURFACE_CURRENT => SURFACE_CASE
    END IF

    DO J = 1, NEWFACE_NUM
        NEWFACE(:,J) = POINT_INDEX(NEWFACE(:,J))
    END DO
    
    DEALLOCATE(SURFACE_CURRENT%SURFACE_POINTS)
    SURFACE_CURRENT%SURFACE_POINTS_NUM = NEWPOINT_NUM
    ALLOCATE(SURFACE_CURRENT%SURFACE_POINTS(3,NEWPOINT_NUM))
    SURFACE_CURRENT%SURFACE_POINTS(:,:) = NEWPOINT(:,:)
    
    DEALLOCATE(SURFACE_CURRENT%SURFACE_FACES)
    SURFACE_CURRENT%SURFACE_FACES_NUM = NEWFACE_NUM
    ALLOCATE(SURFACE_CURRENT%SURFACE_FACES(3,NEWFACE_NUM))
    SURFACE_CURRENT%SURFACE_FACES(:,:) = NEWFACE(:,:)

    END SUBROUTINE TEMP_NEW_POINTFACE_INDEX

    
    
    END MODULE
